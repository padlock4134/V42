import { pipeline } from "@llamaindex/env";
import { Settings } from "../Settings.js";
import { stringifyJSONToMessageContent } from "../internal/utils.js";
import { OpenAI } from "../llm/openai.js";
import { AgentRunner, AgentWorker } from "./base.js";
import { callTool } from "./utils.js";
export class OpenAIAgentWorker extends AgentWorker {
    taskHandler = OpenAIAgent.taskHandler;
}
export class OpenAIAgent extends AgentRunner {
    constructor(params){
        super({
            llm: params.llm ?? Settings.llm instanceof OpenAI ? Settings.llm : new OpenAI(),
            chatHistory: params.chatHistory ?? [],
            runner: new OpenAIAgentWorker(),
            systemPrompt: params.systemPrompt ?? null,
            tools: "tools" in params ? params.tools : params.toolRetriever.retrieve.bind(params.toolRetriever)
        });
    }
    createStore = AgentRunner.defaultCreateStore;
    static taskHandler = async (step)=>{
        const { input } = step;
        const { llm, stream, getTools } = step.context;
        if (input) {
            step.context.store.messages = [
                ...step.context.store.messages,
                input
            ];
        }
        const lastMessage = step.context.store.messages.at(-1).content;
        const tools = await getTools(lastMessage);
        const response = await llm.chat({
            // @ts-expect-error
            stream,
            tools,
            messages: [
                ...step.context.store.messages
            ]
        });
        if (!stream) {
            step.context.store.messages = [
                ...step.context.store.messages,
                response.message
            ];
            const options = response.message.options ?? {};
            if ("toolCall" in options) {
                const { toolCall } = options;
                const targetTool = tools.find((tool)=>tool.metadata.name === toolCall.name);
                const toolOutput = await callTool(targetTool, toolCall);
                step.context.store.toolOutputs.push(toolOutput);
                return {
                    taskStep: step,
                    output: {
                        raw: response.raw,
                        message: {
                            content: stringifyJSONToMessageContent(toolOutput.output),
                            role: "user",
                            options: {
                                toolResult: {
                                    result: toolOutput.output,
                                    isError: toolOutput.isError,
                                    id: toolCall.id
                                }
                            }
                        }
                    },
                    isLast: false
                };
            } else {
                return {
                    taskStep: step,
                    output: response,
                    isLast: true
                };
            }
        } else {
            const responseChunkStream = new ReadableStream({
                async start (controller) {
                    for await (const chunk of response){
                        controller.enqueue(chunk);
                    }
                    controller.close();
                }
            });
            const [pipStream, finalStream] = responseChunkStream.tee();
            const reader = pipStream.getReader();
            const { value } = await reader.read();
            reader.releaseLock();
            if (value === undefined) {
                throw new Error("first chunk value is undefined, this should not happen");
            }
            // check if first chunk has tool calls, if so, this is a function call
            // otherwise, it's a regular message
            const hasToolCall = !!(value.options && "toolCall" in value.options);
            if (hasToolCall) {
                // you need to consume the response to get the full toolCalls
                const toolCalls = await pipeline(pipStream, async (iter)=>{
                    const toolCalls = new Map();
                    for await (const chunk of iter){
                        if (chunk.options && "toolCall" in chunk.options) {
                            const toolCall = chunk.options.toolCall;
                            toolCalls.set(toolCall.id, toolCall);
                        }
                    }
                    return [
                        ...toolCalls.values()
                    ];
                });
                for (const toolCall of toolCalls){
                    const targetTool = tools.find((tool)=>tool.metadata.name === toolCall.name);
                    step.context.store.messages = [
                        ...step.context.store.messages,
                        {
                            role: "assistant",
                            content: "",
                            options: {
                                toolCall
                            }
                        }
                    ];
                    const toolOutput = await callTool(targetTool, toolCall);
                    step.context.store.messages = [
                        ...step.context.store.messages,
                        {
                            role: "user",
                            content: stringifyJSONToMessageContent(toolOutput.output),
                            options: {
                                toolResult: {
                                    result: toolOutput.output,
                                    isError: toolOutput.isError,
                                    id: toolCall.id
                                }
                            }
                        }
                    ];
                    step.context.store.toolOutputs.push(toolOutput);
                }
                return {
                    taskStep: step,
                    output: null,
                    isLast: false
                };
            } else {
                return {
                    taskStep: step,
                    output: finalStream,
                    isLast: true
                };
            }
        }
    };
}
