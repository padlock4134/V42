import { getCallbackManager } from "../internal/settings/CallbackManager.js";
import { isAsyncIterable, prettifyError } from "../internal/utils.js";
export async function callTool(tool, toolCall) {
    if (!tool) {
        const output = `Tool ${toolCall.name} does not exist.`;
        return {
            tool,
            input: toolCall.input,
            output,
            isError: true
        };
    }
    const call = tool.call;
    let output;
    if (!call) {
        output = `Tool ${tool.metadata.name} (remote:${toolCall.name}) does not have a implementation.`;
        return {
            tool,
            input: toolCall.input,
            output,
            isError: true
        };
    }
    try {
        let input = toolCall.input;
        if (typeof input === "string") {
            input = JSON.parse(input);
        }
        getCallbackManager().dispatchEvent("llm-tool-call", {
            payload: {
                toolCall: {
                    ...toolCall
                }
            }
        });
        output = await call.call(tool, input);
        const toolOutput = {
            tool,
            input: toolCall.input,
            output,
            isError: false
        };
        getCallbackManager().dispatchEvent("llm-tool-result", {
            payload: {
                toolCall: {
                    ...toolCall
                },
                toolResult: {
                    ...toolOutput
                }
            }
        });
        return toolOutput;
    } catch (e) {
        output = prettifyError(e);
    }
    return {
        tool,
        input: toolCall.input,
        output,
        isError: true
    };
}
export async function consumeAsyncIterable(input) {
    if (isAsyncIterable(input)) {
        const result = {
            content: "",
            // only assistant will give streaming response
            role: "assistant",
            options: {}
        };
        for await (const chunk of input){
            result.content += chunk.delta;
            if (chunk.options) {
                result.options = {
                    ...result.options,
                    ...chunk.options
                };
            }
        }
        return result;
    } else {
        return input;
    }
}
export function createReadableStream(asyncIterable) {
    return new ReadableStream({
        async start (controller) {
            for await (const chunk of asyncIterable){
                controller.enqueue(chunk);
            }
            controller.close();
        }
    });
}
