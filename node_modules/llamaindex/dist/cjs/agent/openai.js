"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    OpenAIAgent: function() {
        return OpenAIAgent;
    },
    OpenAIAgentWorker: function() {
        return OpenAIAgentWorker;
    }
});
const _env = require("@llamaindex/env");
const _Settings = require("../Settings.js");
const _utils = require("../internal/utils.js");
const _openai = require("../llm/openai.js");
const _base = require("./base.js");
const _utils1 = require("./utils.js");
class OpenAIAgentWorker extends _base.AgentWorker {
    taskHandler = OpenAIAgent.taskHandler;
}
class OpenAIAgent extends _base.AgentRunner {
    constructor(params){
        super({
            llm: params.llm ?? _Settings.Settings.llm instanceof _openai.OpenAI ? _Settings.Settings.llm : new _openai.OpenAI(),
            chatHistory: params.chatHistory ?? [],
            runner: new OpenAIAgentWorker(),
            systemPrompt: params.systemPrompt ?? null,
            tools: "tools" in params ? params.tools : params.toolRetriever.retrieve.bind(params.toolRetriever)
        });
    }
    createStore = _base.AgentRunner.defaultCreateStore;
    static taskHandler = async (step)=>{
        const { input } = step;
        const { llm, stream, getTools } = step.context;
        if (input) {
            step.context.store.messages = [
                ...step.context.store.messages,
                input
            ];
        }
        const lastMessage = step.context.store.messages.at(-1).content;
        const tools = await getTools(lastMessage);
        const response = await llm.chat({
            // @ts-expect-error
            stream,
            tools,
            messages: [
                ...step.context.store.messages
            ]
        });
        if (!stream) {
            step.context.store.messages = [
                ...step.context.store.messages,
                response.message
            ];
            const options = response.message.options ?? {};
            if ("toolCall" in options) {
                const { toolCall } = options;
                const targetTool = tools.find((tool)=>tool.metadata.name === toolCall.name);
                const toolOutput = await (0, _utils1.callTool)(targetTool, toolCall);
                step.context.store.toolOutputs.push(toolOutput);
                return {
                    taskStep: step,
                    output: {
                        raw: response.raw,
                        message: {
                            content: (0, _utils.stringifyJSONToMessageContent)(toolOutput.output),
                            role: "user",
                            options: {
                                toolResult: {
                                    result: toolOutput.output,
                                    isError: toolOutput.isError,
                                    id: toolCall.id
                                }
                            }
                        }
                    },
                    isLast: false
                };
            } else {
                return {
                    taskStep: step,
                    output: response,
                    isLast: true
                };
            }
        } else {
            const responseChunkStream = new ReadableStream({
                async start (controller) {
                    for await (const chunk of response){
                        controller.enqueue(chunk);
                    }
                    controller.close();
                }
            });
            const [pipStream, finalStream] = responseChunkStream.tee();
            const reader = pipStream.getReader();
            const { value } = await reader.read();
            reader.releaseLock();
            if (value === undefined) {
                throw new Error("first chunk value is undefined, this should not happen");
            }
            // check if first chunk has tool calls, if so, this is a function call
            // otherwise, it's a regular message
            const hasToolCall = !!(value.options && "toolCall" in value.options);
            if (hasToolCall) {
                // you need to consume the response to get the full toolCalls
                const toolCalls = await (0, _env.pipeline)(pipStream, async (iter)=>{
                    const toolCalls = new Map();
                    for await (const chunk of iter){
                        if (chunk.options && "toolCall" in chunk.options) {
                            const toolCall = chunk.options.toolCall;
                            toolCalls.set(toolCall.id, toolCall);
                        }
                    }
                    return [
                        ...toolCalls.values()
                    ];
                });
                for (const toolCall of toolCalls){
                    const targetTool = tools.find((tool)=>tool.metadata.name === toolCall.name);
                    step.context.store.messages = [
                        ...step.context.store.messages,
                        {
                            role: "assistant",
                            content: "",
                            options: {
                                toolCall
                            }
                        }
                    ];
                    const toolOutput = await (0, _utils1.callTool)(targetTool, toolCall);
                    step.context.store.messages = [
                        ...step.context.store.messages,
                        {
                            role: "user",
                            content: (0, _utils.stringifyJSONToMessageContent)(toolOutput.output),
                            options: {
                                toolResult: {
                                    result: toolOutput.output,
                                    isError: toolOutput.isError,
                                    id: toolCall.id
                                }
                            }
                        }
                    ];
                    step.context.store.toolOutputs.push(toolOutput);
                }
                return {
                    taskStep: step,
                    output: null,
                    isLast: false
                };
            } else {
                return {
                    taskStep: step,
                    output: finalStream,
                    isLast: true
                };
            }
        }
    };
}
