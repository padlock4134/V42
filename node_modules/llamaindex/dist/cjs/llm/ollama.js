"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Ollama", {
    enumerable: true,
    get: function() {
        return Ollama;
    }
});
const _browser = /*#__PURE__*/ _interop_require_default(require("ollama/browser"));
const _types = require("../embeddings/types.js");
const _utils = require("./utils.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const messageAccessor = (part)=>{
    return {
        raw: part,
        delta: part.message.content
    };
};
const completionAccessor = (part)=>{
    return {
        text: part.response,
        raw: part
    };
};
class Ollama extends _types.BaseEmbedding {
    hasStreaming = true;
    // https://ollama.ai/library
    model;
    options = {
        num_ctx: 4096,
        top_p: 0.9,
        temperature: 0.7
    };
    constructor(params){
        super();
        this.model = params.model;
        if (params.options) {
            this.options = {
                ...this.options,
                ...params.options
            };
        }
    }
    get metadata() {
        const { temperature, top_p, num_ctx } = this.options;
        return {
            model: this.model,
            temperature: temperature,
            topP: top_p,
            maxTokens: undefined,
            contextWindow: num_ctx,
            tokenizer: undefined
        };
    }
    async chat(params) {
        const { messages, stream } = params;
        const payload = {
            model: this.model,
            messages: messages.map((message)=>({
                    role: message.role,
                    content: (0, _utils.extractText)(message.content)
                })),
            stream: !!stream,
            options: {
                ...this.options
            }
        };
        if (!stream) {
            const chatResponse = await _browser.default.chat({
                ...payload,
                stream: false
            });
            return {
                message: {
                    role: "assistant",
                    content: chatResponse.message.content
                },
                raw: chatResponse
            };
        } else {
            const stream = await _browser.default.chat({
                ...payload,
                stream: true
            });
            return (0, _utils.streamConverter)(stream, messageAccessor);
        }
    }
    async complete(params) {
        const { prompt, stream } = params;
        const payload = {
            model: this.model,
            prompt: (0, _utils.extractText)(prompt),
            stream: !!stream,
            options: {
                ...this.options
            }
        };
        if (!stream) {
            const response = await _browser.default.generate({
                ...payload,
                stream: false
            });
            return {
                text: response.response,
                raw: response
            };
        } else {
            const stream = await _browser.default.generate({
                ...payload,
                stream: true
            });
            return (0, _utils.streamConverter)(stream, completionAccessor);
        }
    }
    async getEmbedding(prompt) {
        const payload = {
            model: this.model,
            prompt,
            options: {
                ...this.options
            }
        };
        const response = await _browser.default.embeddings({
            ...payload
        });
        return response.embedding;
    }
    async getTextEmbedding(text) {
        return this.getEmbedding(text);
    }
    async getQueryEmbedding(query) {
        return this.getEmbedding(query);
    }
    // ollama specific methods, inherited from the ollama library
    static async list() {
        const { models } = await _browser.default.list();
        return models;
    }
    static async detail(modelName, options) {
        return _browser.default.show({
            model: modelName,
            ...options
        });
    }
    static async create(modelName, options) {
        return _browser.default.create({
            model: modelName,
            ...options,
            stream: options ? !!options.stream : false
        });
    }
    static async delete(modelName) {
        return _browser.default.delete({
            model: modelName
        });
    }
    static async copy(source, destination) {
        return _browser.default.copy({
            source,
            destination
        });
    }
    static async pull(modelName, options) {
        return _browser.default.pull({
            model: modelName,
            ...options,
            stream: options ? !!options.stream : false
        });
    }
    static async push(modelName, options) {
        return _browser.default.push({
            model: modelName,
            ...options,
            stream: options ? !!options.stream : false
        });
    }
}
