import {ListAppsRequest as $hgUW1$ListAppsRequest, ListRunnersRequest as $hgUW1$ListRunnersRequest, PostAppsRequest as $hgUW1$PostAppsRequest, PostRunnersRequest as $hgUW1$PostRunnersRequest, GetAppRequest as $hgUW1$GetAppRequest, GetRunnerRequest as $hgUW1$GetRunnerRequest, DeleteAppRequest as $hgUW1$DeleteAppRequest, DeleteRunnersRequest as $hgUW1$DeleteRunnersRequest, ListDatasetsRequest as $hgUW1$ListDatasetsRequest, ListModelsRequest as $hgUW1$ListModelsRequest, ListWorkflowsRequest as $hgUW1$ListWorkflowsRequest, ListModulesRequest as $hgUW1$ListModulesRequest, ListInstalledModuleVersionsRequest as $hgUW1$ListInstalledModuleVersionsRequest, ListConceptsRequest as $hgUW1$ListConceptsRequest, PostDatasetsRequest as $hgUW1$PostDatasetsRequest, PostModelsRequest as $hgUW1$PostModelsRequest, PostModulesRequest as $hgUW1$PostModulesRequest, PostWorkflowsRequest as $hgUW1$PostWorkflowsRequest, GetModelRequest as $hgUW1$GetModelRequest, GetWorkflowRequest as $hgUW1$GetWorkflowRequest, GetDatasetRequest as $hgUW1$GetDatasetRequest, DeleteDatasetsRequest as $hgUW1$DeleteDatasetsRequest, DeleteModelsRequest as $hgUW1$DeleteModelsRequest, DeleteWorkflowsRequest as $hgUW1$DeleteWorkflowsRequest, DeleteModulesRequest as $hgUW1$DeleteModulesRequest, ListModelTypesRequest as $hgUW1$ListModelTypesRequest, DeleteModelVersionRequest as $hgUW1$DeleteModelVersionRequest, PostModelVersionsRequest as $hgUW1$PostModelVersionsRequest, ListModelVersionsRequest as $hgUW1$ListModelVersionsRequest, PostModelOutputsRequest as $hgUW1$PostModelOutputsRequest, PostInputsRequest as $hgUW1$PostInputsRequest, PatchInputsRequest as $hgUW1$PatchInputsRequest, PostAnnotationsRequest as $hgUW1$PostAnnotationsRequest, GetInputsAddJobRequest as $hgUW1$GetInputsAddJobRequest, CancelInputsAddJobRequest as $hgUW1$CancelInputsAddJobRequest, ListInputsRequest as $hgUW1$ListInputsRequest, DeleteInputsRequest as $hgUW1$DeleteInputsRequest, Pagination as $hgUW1$Pagination, PostInputsSearchesRequest as $hgUW1$PostInputsSearchesRequest, PostAnnotationsSearchesRequest as $hgUW1$PostAnnotationsSearchesRequest, PostWorkflowResultsRequest as $hgUW1$PostWorkflowResultsRequest, ListWorkflowVersionsRequest as $hgUW1$ListWorkflowVersionsRequest, PostDatasetVersionsRequest as $hgUW1$PostDatasetVersionsRequest, DeleteDatasetVersionsRequest as $hgUW1$DeleteDatasetVersionsRequest, ListDatasetVersionsRequest as $hgUW1$ListDatasetVersionsRequest} from "clarifai-nodejs-grpc/proto/clarifai/api/service_pb";
import $hgUW1$clarifainodejsgrpcprotoclarifaiapiresources_pb, {Workflow as $hgUW1$Workflow, App as $hgUW1$App, Runner as $hgUW1$Runner, UserAppIDSet as $hgUW1$UserAppIDSet, Dataset as $hgUW1$Dataset, Model as $hgUW1$Model, Module as $hgUW1$Module, ModelVersion as $hgUW1$ModelVersion, WorkflowNode as $hgUW1$WorkflowNode, OutputInfo as $hgUW1$OutputInfo, Geo as $hgUW1$Geo, GeoPoint as $hgUW1$GeoPoint, Concept as $hgUW1$Concept, Input as $hgUW1$Input, Data as $hgUW1$Data, Image as $hgUW1$Image, Video as $hgUW1$Video, Audio as $hgUW1$Audio, Text as $hgUW1$Text, Annotation as $hgUW1$Annotation, Region as $hgUW1$Region, RegionInfo as $hgUW1$RegionInfo, BoundingBox as $hgUW1$BoundingBox, Polygon as $hgUW1$Polygon, Point as $hgUW1$Point, GeoLimit as $hgUW1$GeoLimit, Rank as $hgUW1$Rank, Filter as $hgUW1$Filter, Query as $hgUW1$Query, Search as $hgUW1$Search, OutputConfig as $hgUW1$OutputConfig, WorkflowState as $hgUW1$WorkflowState, DatasetVersion as $hgUW1$DatasetVersion} from "clarifai-nodejs-grpc/proto/clarifai/api/resources_pb";
import {StatusCode as $hgUW1$StatusCode} from "clarifai-nodejs-grpc/proto/clarifai/api/status/status_code_pb";
import {Timestamp as $hgUW1$Timestamp} from "google-protobuf/google/protobuf/timestamp_pb";
import {grpc as $hgUW1$grpc} from "clarifai-nodejs-grpc";
import {V2Client as $hgUW1$V2Client} from "clarifai-nodejs-grpc/proto/clarifai/api/service_grpc_pb";
import $hgUW1$process, {env as $hgUW1$env, version as $hgUW1$version} from "process";
import $hgUW1$fs, {existsSync as $hgUW1$existsSync, readFileSync as $hgUW1$readFileSync, writeFileSync as $hgUW1$writeFileSync, createWriteStream as $hgUW1$createWriteStream} from "fs";
import $hgUW1$os, {platform as $hgUW1$platform, release as $hgUW1$release} from "os";
import {status as $hgUW1$status} from "@grpc/grpc-js";
import {Map as $hgUW1$Map, Message as $hgUW1$Message} from "google-protobuf";
import $hgUW1$jsyaml, {load as $hgUW1$load, dump as $hgUW1$dump} from "js-yaml";
import {v4 as $hgUW1$v4} from "uuid";
import {fromProtobufObject as $hgUW1$fromProtobufObject} from "from-protobuf-object";
import {flatten as $hgUW1$flatten} from "safe-flat";
import {URL as $hgUW1$URL} from "url";
import {z as $hgUW1$z} from "zod";
import {Struct as $hgUW1$Struct} from "google-protobuf/google/protobuf/struct_pb";
import {Buffer as $hgUW1$Buffer} from "buffer";
import $hgUW1$path from "path";
import {parse as $hgUW1$parse} from "csv-parse";
import {finished as $hgUW1$finished} from "stream/promises";
import $hgUW1$lodashchunk from "lodash/chunk";
import {Status as $hgUW1$Status} from "clarifai-nodejs-grpc/proto/clarifai/api/status/status_pb";
import $hgUW1$async from "async";
import $hgUW1$lodashcompact from "lodash/compact";
import {PDFReader as $hgUW1$PDFReader, DocxReader as $hgUW1$DocxReader, TextFileReader as $hgUW1$TextFileReader, SimpleDirectoryReader as $hgUW1$SimpleDirectoryReader, SentenceSplitter as $hgUW1$SentenceSplitter} from "llamaindex";
import $hgUW1$axios from "axios";
import $hgUW1$tmp from "tmp";


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $1eac708f26a71747$exports = {};

$parcel$export($1eac708f26a71747$exports, "User", () => $1eac708f26a71747$export$1f44aaf2ec115b54);





const $24626ea78b535002$var$DEFAULT_BASE = "https://api.clarifai.com";
const $24626ea78b535002$var$DEFAULT_UI = "https://clarifai.com";
const $24626ea78b535002$var$validResourceTypes = [
    "modules",
    "models",
    "concepts",
    "inputs",
    "workflows",
    "tasks",
    "installed_module_versions"
];
// Map from base domain to True / False for whether the base has https or http.
const $24626ea78b535002$var$baseHttpsCache = {};
const $24626ea78b535002$var$uiHttpsCache = {};
function $24626ea78b535002$var$getHostnameFromUrl(url) {
    // Remove protocol (http, https) if present
    let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
    // Remove port number if present
    hostname = hostname.split(":")[0];
    // Remove path if present
    hostname = hostname.split("?")[0];
    return hostname;
}
function $24626ea78b535002$export$d2adf65b87e47523() {
    Object.keys($24626ea78b535002$var$baseHttpsCache).forEach((key)=>delete $24626ea78b535002$var$baseHttpsCache[key]);
    Object.keys($24626ea78b535002$var$uiHttpsCache).forEach((key)=>delete $24626ea78b535002$var$uiHttpsCache[key]);
}
function $24626ea78b535002$export$453001aa752caf0f(cache, url) {
    const HTTPS = true;
    const HTTP = false;
    if (url.startsWith("https://")) {
        url = url.replace("https://", "");
        cache[url] = HTTPS;
    } else if (url.startsWith("http://")) {
        url = url.replace("http://", "");
        cache[url] = HTTP;
    } else if (!(url in cache)) {
        // Assuming HTTPS for any URLs without a scheme that end with .clarifai.com
        const hostname = $24626ea78b535002$var$getHostnameFromUrl(url);
        if (hostname && hostname.endsWith(".clarifai.com")) cache[url] = HTTPS;
        else // For URLs without a scheme and not ending with .clarifai.com, prompt user to provide the scheme
        throw new Error(`Please provide a valid scheme for the ${url}, either use http:// or https://`);
    }
    return url;
}
class $24626ea78b535002$export$b0f6169af04081a6 {
    /**
   * A helper to get the authorization information needed to make API calls with the grpc
   * client to a specific app using a personal access token.
   *
   * There are class methods to make this object easily from either query_params provided by streamlit or from env vars.
   *
   * Note: only one of personal access token (pat) or a session token (token) can be provided.
   * Always use PATs in your code and never session tokens, those are only provided internal UI code.
   *
   * @param user_id - A user id who owns the resource you want to make calls to.
   * @param app_id - An app id for the application that owns the resource you want to interact with.
   * @param pat - A personal access token.
   * @param token - A session token (internal use only, always use a PAT).
   * @param base - A url to the API endpoint to hit. Examples include api.clarifai.com,
   *               https://api.clarifai.com (default), https://host:port, http://host:port,
   *               host:port (will be treated as http, not https). It's highly recommended to include
   *               the http:// or https:// otherwise we need to check the endpoint to determine if it has SSL during this __init__.
   * @param ui - A url to the UI. Examples include clarifai.com,
   *             https://clarifai.com (default), https://host:port, http://host:port,
   *             host:port (will be treated as http, not https). It's highly recommended to include
   *             the http:// or https:// otherwise we need to check the endpoint to determine if it has SSL during this __init__.
   * @param rootCertificatesPath - path to the root certificates file. This is only used for grpc secure channels.
   * @param validate - Whether to validate the inputs. This is useful for overriding vars then validating.
   */ constructor(userId, appId, pat, token = "", base = $24626ea78b535002$var$DEFAULT_BASE, ui = $24626ea78b535002$var$DEFAULT_UI, rootCertificatesPath = "", validate = true){
        this.userId = userId;
        this.appId = appId;
        this._pat = pat;
        this.token = token;
        this._rootCertificatesPath = rootCertificatesPath;
        this._base = base;
        this._ui = ui;
        this.setBase(base);
        this.setUi(ui);
        if (validate) this.validate();
    }
    validate() {
        if (this.userId === "") throw new Error("Need 'user_id' to not be empty in the query params or use CLARIFAI_USER_ID env var");
        if (this.appId === "") throw new Error("Need 'app_id' to not be empty in the query params or use CLARIFAI_APP_ID env var");
        if (this._pat !== "" && this.token !== "") throw new Error("A personal access token OR a session token need to be provided, but you cannot provide both.");
        else if (this._pat === "" && this.token === "") throw new Error("Need 'pat' or 'token' in the query params or use one of the CLARIFAI_PAT or CLARIFAI_SESSION_TOKEN env vars");
        else if (this._rootCertificatesPath && !(0, $hgUW1$fs).existsSync(this._rootCertificatesPath)) throw new Error(`Root certificates path ${this._rootCertificatesPath} does not exist`);
    }
    /**
   * Will look for the following env vars:
   * user_id: CLARIFAI_USER_ID env var.
   * app_id: CLARIFAI_APP_ID env var.
   * one of:
   *   token: CLARIFAI_SESSION_TOKEN env var.
   *   pat: CLARIFAI_PAT env var.
   * base: CLARIFAI_API_BASE env var.
   *
   * @param validate - Whether to validate the inputs. This is useful for overriding vars then validating.
   */ static fromEnv(validate = true) {
        const userId = (0, $hgUW1$process).env.CLARIFAI_USER_ID || "";
        const appId = (0, $hgUW1$process).env.CLARIFAI_APP_ID || "";
        const token = (0, $hgUW1$process).env.CLARIFAI_SESSION_TOKEN || "";
        const pat = (0, $hgUW1$process).env.CLARIFAI_PAT || "";
        const base = (0, $hgUW1$process).env.CLARIFAI_API_BASE || $24626ea78b535002$var$DEFAULT_BASE;
        const ui = (0, $hgUW1$process).env.CLARIFAI_UI || $24626ea78b535002$var$DEFAULT_UI;
        const rootCertificatesPath = (0, $hgUW1$process).env.CLARIFAI_ROOT_CERTIFICATES_PATH || "";
        return new $24626ea78b535002$export$b0f6169af04081a6(userId, appId, pat, token, base, ui, rootCertificatesPath, validate);
    }
    /**
   * Get the gRPC metadata that contains either the session token or the PAT to use.
   *
   * @param userId - Optional user ID to override the default.
   * @param appId - Optional app ID to override the default.
   * @returns The metadata needed to send with all gRPC API calls in the API client.
   */ getUserAppIdProto(userId, appId) {
        const effectiveUserId = userId ?? this.userId;
        const effectiveAppId = appId ?? this.appId;
        const userAppIdSet = new (0, $hgUW1$clarifainodejsgrpcprotoclarifaiapiresources_pb).UserAppIDSet();
        userAppIdSet.setUserId(effectiveUserId);
        userAppIdSet.setAppId(effectiveAppId);
        return userAppIdSet;
    }
    /**
   * Get the gRPC metadata that contains either the session token or the PAT to use.
   *
   * @returns The metadata needed to send with all gRPC API calls in the API client.
   */ get metadata() {
        if (this._pat !== "") return [
            [
                "authorization",
                `Key ${this._pat}`
            ]
        ];
        else if (this.token !== "") return [
            [
                "x-clarifai-session-token",
                this.token
            ]
        ];
        else throw new Error("'token' or 'pat' needed to be provided in the query params or env vars.");
    }
    /**
   * Get the API gRPC stub using the right channel based on the API endpoint base.
   * TODO: This method is currently not implemented due to the lack of a gRPC V2Stub in clarifai-node.js.
   *
   * @returns V2Client - The gRPC client to use to make API calls.
   */ getStub() {
        if (!(this._base in $24626ea78b535002$var$baseHttpsCache)) throw new Error(`Cannot determine if base ${this._base} is https`);
        const https = $24626ea78b535002$var$baseHttpsCache[this._base];
        let client;
        if (https) {
            if (this._rootCertificatesPath) client = new (0, $hgUW1$V2Client)(this._base, (0, $hgUW1$grpc).ChannelCredentials.createSsl((0, $hgUW1$fs).readFileSync(this._rootCertificatesPath)));
            else client = new (0, $hgUW1$V2Client)(this._base, (0, $hgUW1$grpc).ChannelCredentials.createSsl());
        } else {
            let host;
            let port = 80;
            if (this._base.includes(":")) [host, port] = this._base.split(":").map((item, index)=>index === 1 ? parseInt(item) : item);
            else host = this._base;
            client = new (0, $hgUW1$V2Client)(`${host}:${port}`, (0, $hgUW1$grpc).ChannelCredentials.createInsecure());
        }
        return client;
    }
    /**
   * Return the domain for the UI.
   */ get ui() {
        if (!(this._ui in $24626ea78b535002$var$uiHttpsCache)) throw new Error(`Cannot determine if ui ${this._ui} is https`);
        const https = $24626ea78b535002$var$uiHttpsCache[this._ui];
        if (https) return this._ui.startsWith("https://") ? this._ui : `https://${this._ui}`;
        else return this._ui.startsWith("http://") ? this._ui : `http://${this._ui}`;
    }
    /**
   * set the base domain for the API.
   * @param base - The base domain to set.
   */ setBase(base) {
        this._base = $24626ea78b535002$export$453001aa752caf0f($24626ea78b535002$var$baseHttpsCache, base);
    }
    /**
   * set the domain for the UI.
   * @param ui - The UI domain to set.
   */ setUi(ui) {
        this._ui = $24626ea78b535002$export$453001aa752caf0f($24626ea78b535002$var$uiHttpsCache, ui);
    }
    /**
   * Return the root certificates path.
   */ get rootCertificatesPath() {
        return this._rootCertificatesPath;
    }
    /**
   * Return the base domain for the API.
   */ get base() {
        if (!(this._base in $24626ea78b535002$var$baseHttpsCache)) throw new Error(`Cannot determine if base ${this._base} is https`);
        const https = $24626ea78b535002$var$baseHttpsCache[this._base];
        if (https) return this._base.startsWith("https://") ? this._base : `https://${this._base}`;
        else return this._base.startsWith("http://") ? this._base : `http://${this._base}`;
    }
    /**
   * Return the personal access token.
   */ get pat() {
        return this._pat;
    }
    /**
   * Returns a string representation of the class.
   */ toString() {
        return `ClarifaiAuthHelper:\n- base: ${this._base}\n- user_id: ${this.userId}\n- app_id: ${this.appId}`;
    }
    /**
   * Return the list of the required environment variables.
   */ static requiredEnvVars() {
        return [
            "CLARIFAI_USER_ID",
            "CLARIFAI_APP_ID",
            "CLARIFAI_PAT"
        ];
    }
    /**
   * Validate the secrets.toml file has been filled with non-empty values for all the auth parameters that are present.
   *
   * @param tomlDict - The dictionary obtained from the secrets.toml file.
   */ static validateSecretsDict(tomlDict) {
        const authKeys = $24626ea78b535002$export$b0f6169af04081a6.requiredEnvVars();
        for (const [key, value] of Object.entries(tomlDict)){
            if (authKeys.includes(key) && value === "") throw new Error(`'${key}' in secrets.toml cannot be empty`);
        }
        // Assuming all non-present keys have non-empty values.
        return true;
    }
    clarifaiUrl({ resourceType: resourceType, resourceId: resourceId, versionId: versionId }) {
        if (!$24626ea78b535002$var$validResourceTypes.includes(resourceType)) throw new Error(`resourceType must be one of ${$24626ea78b535002$var$validResourceTypes.join(", ")} but was ${resourceType}`);
        if (!versionId) return `${this.base}/${this.userId}/${this.appId}/${resourceType}/${resourceId}`;
        return `${this.base}/${this.userId}/${this.appId}/${resourceType}/${resourceId}/versions/${versionId}`;
    }
}




var $df64573ef6d51081$exports = {};
$df64573ef6d51081$exports = JSON.parse('{"name":"clarifai-nodejs","version":"0.0.3","description":"The official Clarifai Node.js SDK","source":"src/index.ts","main":"dist/main.js","module":"dist/module.js","types":"dist/types.d.ts","scripts":{"test":"vitest","test:unit":"vitest unit.test","test:integration":"vitest run integration.test","coverage":"vitest run --coverage","lint:fix":"eslint . --fix --ignore-path .gitignore","lint":"tsc --noEmit --pretty && eslint . --ignore-path .gitignore","watch":"parcel watch","build":"parcel build","generate-docs":"typedoc --plugin typedoc-plugin-markdown --plugin typedoc-plugin-no-inherit --plugin ./typedoc-plugins/expand-object.js --plugin ./typedoc-plugins/include-example --out docs src/"},"files":["dist/"],"repository":{"type":"git","url":"git+https://github.com/Clarifai/clarifai-nodejs.git"},"keywords":["clarifai","clarifai-nodejs","clarifai-typescript"],"author":"Clarifai Inc.","license":"Apache-2.0","bugs":{"url":"https://github.com/Clarifai/clarifai-nodejs/issues"},"homepage":"https://github.com/Clarifai/clarifai-nodejs#readme","devDependencies":{"@parcel/packager-ts":"^2.11.0","@parcel/transformer-typescript-types":"^2.11.0","@types/async":"^3.2.24","@types/google-protobuf":"^3.15.12","@types/js-yaml":"^4.0.9","@types/lodash":"^4.17.0","@types/node":"^20.11.16","@types/tmp":"^0.2.6","@types/uuid":"^9.0.8","@typescript-eslint/eslint-plugin":"^6.19.1","@typescript-eslint/parser":"^6.19.1","@vitest/coverage-v8":"^1.3.1","dotenv":"^16.4.5","eslint":"^8.56.0","eslint-config-prettier":"^9.1.0","eslint-plugin-prettier":"^5.1.3","parcel":"^2.11.0","prettier":"3.2.4","typedoc":"^0.25.12","typedoc-plugin-include-example":"^1.2.0","typedoc-plugin-markdown":"^3.17.1","typedoc-plugin-no-inherit":"^1.4.0","typescript":"^5.3.3","vitest":"^1.3.1"},"dependencies":{"@grpc/grpc-js":"^1.10.1","@grpc/proto-loader":"^0.7.10","async":"^3.2.5","axios":"^1.6.8","chalk":"^5.3.0","clarifai-nodejs-grpc":"^10.3.2","csv-parse":"^5.5.5","from-protobuf-object":"^1.0.2","google-protobuf":"^3.21.2","js-yaml":"^4.1.0","llamaindex":"^0.2.13","lodash":"^4.17.21","safe-flat":"^2.1.0","tmp":"^0.2.3","uuid":"^9.0.1","winston":"^3.11.0","zod":"^3.22.4"}}');


const $28ac839a9eca26f5$var$CLIENT_VERSION = (0, (/*@__PURE__*/$parcel$interopDefault($df64573ef6d51081$exports))).version;
const $28ac839a9eca26f5$var$OS_VER = $hgUW1$platform() + " " + $hgUW1$release();
const $28ac839a9eca26f5$var$NODE_VERSION = (0, $hgUW1$version);
class $28ac839a9eca26f5$export$ed0b8b496332122d extends Error {
}
class $28ac839a9eca26f5$export$f2e832acab1bdd79 extends Error {
    constructor(resource, params, method, response = null){
        super();
        this.resource = resource;
        this.params = params;
        this.method = method;
        this.response = response;
        this.error_code = "N/A";
        this.error_desc = "N/A";
        this.error_details = "N/A";
        let response_json = "N/A";
        if (response) {
            // TODO: Might need a function to convert response to JSON object
            const response_json_dict = response; // Adapt based on actual protobuf usage
            this.error_code = response_json_dict?.status?.code ?? "N/A";
            this.error_desc = response_json_dict?.status?.description ?? "N/A";
            this.error_details = response_json_dict?.status?.details ?? "N/A";
            response_json = JSON.stringify(response_json_dict.status, null, 2);
        }
        const current_ts_str = Date.now().toString();
        const msg = `${method} ${resource} FAILED(${current_ts_str}).  error_code: ${this.error_code}, error_description: ${this.error_desc}, error_details: ${this.error_details}
 >> Node client ${$28ac839a9eca26f5$var$CLIENT_VERSION} with Node ${$28ac839a9eca26f5$var$NODE_VERSION} on ${$28ac839a9eca26f5$var$OS_VER}
 >> ${method} ${resource}
 >> REQUEST(${current_ts_str}) ${JSON.stringify(params, null, 2)}
 >> RESPONSE(${current_ts_str}) ${response_json}`;
        this.message = msg;
    }
}
class $28ac839a9eca26f5$export$40f4c0b52fedfe21 extends Error {
}
class $28ac839a9eca26f5$export$3b14aa8c543ca7db extends Error {
}
class $28ac839a9eca26f5$export$145273558d58e0ac extends Error {
}
function $28ac839a9eca26f5$export$a135e81e9a047f61(url) {
    try {
        return url.slice(0, $28ac839a9eca26f5$export$833c4bb0a5e9ca1f(url, "/", 4) + 1);
    } catch (e) {
        return "";
    }
}
function $28ac839a9eca26f5$export$833c4bb0a5e9ca1f(str, char, n) {
    let firstIndex = str.indexOf(char);
    let count = 1;
    while(firstIndex >= 0 && count < n){
        firstIndex = str.indexOf(char, firstIndex + 1);
        count++;
    }
    return firstIndex;
}



function $199a96159c1768e2$export$c47c3f0a3bfd6dd8(key, envKey, data) {
    if (data?.[key]) return data[key];
    else return $199a96159c1768e2$var$getFromEnv(key, envKey);
}
/**
 * Get a value from an environment variable.
 */ function $199a96159c1768e2$var$getFromEnv(key, envKey) {
    if ($hgUW1$env?.[envKey]) return $hgUW1$env[envKey];
    else throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Did not find \`${key}\`, please add an environment variable \`${envKey}\` which contains it, or pass \`${key}\` as a named parameter.`);
}
function $199a96159c1768e2$export$54865a3d4693b845(func, client) {
    return (request, metadata, options)=>{
        return new Promise((resolve, reject)=>{
            func.bind(client)(request, metadata, options, (error, response)=>{
                if (error) return reject(error);
                resolve(response);
            });
        });
    };
}
function $199a96159c1768e2$export$2321aea138b44780(obj1, obj2) {
    const result = {
        ...obj1
    };
    Object.entries(obj2).forEach(([key, value])=>{
        if (value) result[key] = value;
    });
    return result;
}
class $199a96159c1768e2$export$8bd55c4683eb5fb0 {
    constructor({ count: count } = {
        count: 0
    }){
        this.count = count;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (this.count < 1) {
            this.count += 1;
            return {
                value: 0.1,
                done: false
            };
        } else if (this.count < 7) {
            this.count += 1;
            return {
                value: 0.01 * Math.pow(2, this.count + 4),
                done: false
            };
        } else return {
            value: 0.01 * Math.pow(2, 10),
            done: false
        };
    }
}






const $6127311445906dca$var$throttleStatusCodes = new Set([
    (0, $hgUW1$StatusCode).CONN_THROTTLED,
    (0, $hgUW1$StatusCode).CONN_EXCEED_HOURLY_LIMIT
]);
const $6127311445906dca$var$retryCodesGrpc = new Set([
    (0, $hgUW1$status).UNAVAILABLE
]);
class $6127311445906dca$export$794bcf57aceab7f0 {
    constructor(authHelper){
        if (!authHelper) this.authHelper = (0, $24626ea78b535002$export$b0f6169af04081a6).fromEnv();
        else this.authHelper = authHelper;
        this.stub = this.authHelper.getStub();
        this.client = this.stub;
        this.metadata = this.authHelper.metadata;
    }
    async makeCall(methodName, request) {
        const metadata = new (0, $hgUW1$grpc).Metadata();
        const authMetadata = this.metadata;
        authMetadata.forEach((meta)=>{
            metadata.set(meta?.[0], meta?.[1]);
        });
        return new Promise((resolve, reject)=>{
            const methodFunction = this.stub[methodName];
            if (typeof methodFunction !== "function") {
                reject(new Error(`Method ${methodName} does not exist on stub`));
                return;
            }
            // TODO - Fix the type issue with manually invoking the methodFunction
            // @ts-expect-error - TS doesn't know that methodFunction has overloads & only expects 5 arguments
            methodFunction.call(this.stub, request, metadata, {}, (err, response)=>{
                if (err) reject(err);
                else // TODO - Fix the type issue with the response
                // @ts-expect-error - Response type is not fully inferred
                resolve(response);
            });
        });
    }
    async makeCallPromise(endpoint, requestData) {
        const metadata = new (0, $hgUW1$grpc).Metadata();
        const authMetadata = this.metadata;
        authMetadata.forEach((meta)=>{
            metadata.set(meta?.[0], meta?.[1]);
        });
        return await endpoint(requestData, metadata, {});
    }
}
class $6127311445906dca$export$ed0bcf31db9077ce extends $6127311445906dca$export$794bcf57aceab7f0 {
    constructor(authHelper, maxAttempts = 10, backoffTime = 5){
        super(authHelper);
        this.maxAttempts = maxAttempts;
        this.backoffTime = backoffTime;
    }
    async makeCall(methodName, request) {
        for(let attempt = 1; attempt <= this.maxAttempts; attempt++)try {
            const response = await super.makeCall(methodName, request);
            return response;
        } catch (err) {
            const errorCode = err.code;
            if ($6127311445906dca$var$retryCodesGrpc.has(errorCode) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
            err.status?.code in $6127311445906dca$var$throttleStatusCodes) {
                console.log(`Attempt ${attempt} failed, retrying...`);
                if (attempt < this.maxAttempts) {
                    await new Promise((resolve)=>setTimeout(resolve, this.backoffTime * 1000));
                    continue;
                }
            }
            throw err;
        }
        throw new Error("Max retry attempts reached");
    }
    async makeCallPromise(endpoint, requestData) {
        for(let attempt = 1; attempt <= this.maxAttempts; attempt++)try {
            const response = await super.makeCallPromise(endpoint, requestData);
            return response;
        } catch (err) {
            const errorCode = err.code;
            if ($6127311445906dca$var$retryCodesGrpc.has(errorCode) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
            err.status?.code in $6127311445906dca$var$throttleStatusCodes) {
                console.log(`Attempt ${attempt} failed, retrying...`);
                if (attempt < this.maxAttempts) {
                    await new Promise((resolve)=>setTimeout(resolve, this.backoffTime * 1000));
                    continue;
                }
            }
            throw err;
        }
        throw new Error("Max retry attempts reached");
    }
}
function $6127311445906dca$export$59489f973bac32ee(authHelper, maxRetryAttempts = 10) {
    // Assuming AuthorizedStub's constructor can handle a null authHelper by defaulting internally or through another mechanism
    const stub = new $6127311445906dca$export$794bcf57aceab7f0(authHelper);
    if (maxRetryAttempts > 0) return new $6127311445906dca$export$ed0bcf31db9077ce(authHelper, maxRetryAttempts);
    return stub;
}



class $e07b5203d252b812$export$4f22f74eddb7716a {
    /**
   * Constructs a new BaseClient instance with specified configuration options.
   *
   * @param {Object} authConfig Configuration options for the client.
   * @param {string} authConfig.userId A user ID for authentication.
   * @param {string} authConfig.appId An app ID for the application to interact with.
   * @param {string} authConfig.pat A personal access token for authentication. If not provided, it attempts to fetch from environment variables.
   * @param {string} [authConfig.token] An optional token for authentication.
   * @param {string} [authConfig.base='https://api.clarifai.com'] The base URL for the API endpoint. Defaults to 'https://api.clarifai.com'.
   * @param {string} [authConfig.ui='https://clarifai.com'] The URL for the UI. Defaults to 'https://clarifai.com'.
   * @param {string} [authConfig.rootCertificatesPath] Path to the SSL root certificates file, used to establish secure gRPC connections.
   */ constructor(authConfig = {}){
        const pat = (0, $199a96159c1768e2$export$c47c3f0a3bfd6dd8)("pat", "CLARIFAI_PAT", authConfig);
        authConfig.pat = pat;
        this.authHelper = Object.keys(authConfig).length > 0 ? new (0, $24626ea78b535002$export$b0f6169af04081a6)(authConfig.userId, authConfig.appId, authConfig.pat, authConfig.token, authConfig.base, authConfig.ui, authConfig.rootCertificatesPath, false) : (0, $24626ea78b535002$export$b0f6169af04081a6).fromEnv(false); // The validate parameter is set to false explicitly
        this.STUB = (0, $6127311445906dca$export$59489f973bac32ee)(this.authHelper);
        this.metadata = this.authHelper.metadata;
        this.pat = this.authHelper.pat;
        this.userAppId = this.authHelper.getUserAppIdProto();
        this.base = this.authHelper.base;
        this.rootCertificatesPath = this.authHelper.rootCertificatesPath;
    }
    /**
   * Makes a gRPC request to the API.
   *
   * @param method The gRPC method to call.
   * @param argument The argument to pass to the gRPC method.
   * @returns A Promise resolving to the result of the gRPC method call.
   */ async grpcRequest(endpoint, requestData) {
        return await this.STUB.makeCallPromise(endpoint, requestData);
    }
    /**
   * Converts a string to a Timestamp object.
   *
   * @param dateStr The string to convert.
   * @returns A Timestamp object representing the given date string.
   */ convertStringToTimestamp(dateStr) {
        const timestamp = new (0, $hgUW1$Timestamp)();
        // Attempt to parse the date string into a Date object
        const datetimeObj = new Date(dateStr);
        // Check if the date is valid
        if (isNaN(datetimeObj.getTime())) throw new Error("Invalid date string");
        // Convert the Date object to a Timestamp
        timestamp.fromDate(datetimeObj);
        return timestamp;
    }
}



class $f7e2ee1c151bc7f7$export$be1f67df1c66692d extends (0, $e07b5203d252b812$export$4f22f74eddb7716a) {
    constructor({ authConfig: authConfig = {}, pageSize: pageSize = 16 }){
        super(authConfig);
        this.defaultPageSize = pageSize;
    }
    async *listPagesGenerator(endpoint, requestData, pageNo = 1, perPage = this.defaultPageSize) {
        let page = pageNo;
        while(true){
            // Prepare request data
            // @ts-expect-error - TS doesn't know that the method exists
            requestData.setPage(page);
            if (perPage) // @ts-expect-error - TS doesn't know that the method exists
            requestData.setPerPage(perPage);
            // Perform gRPC request
            const response = await this.grpcRequest(endpoint, requestData);
            const responseObject = response.toObject();
            // Check response status
            if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Listing failed with response ${response}`);
            const dataListEntries = Object.entries(responseObject).find(([key, value])=>key !== "status" && Array.isArray(value));
            if (!dataListEntries) break; // If no data list is found, stop pagination
            const [, dataList] = dataListEntries;
            // If the length of the data list is less than perPage, it means we've reached the end
            // @ts-expect-error - TS doesn't know that data format is array
            if (dataList.length === 0) break;
            yield response;
            // If the length of the data list is less than perPage, it means we've reached the end
            // @ts-expect-error - TS doesn't know that data format is array
            if (dataList.length < perPage) break;
            page += 1;
        }
    }
    async listPagesData(endpoint, requestData, pageNo = 1, perPage = this.defaultPageSize) {
        // Prepare request data
        // @ts-expect-error - TS doesn't know that the method exists
        requestData.setPage(pageNo);
        if (perPage) // @ts-expect-error - TS doesn't know that the method exists
        requestData.setPerPage(perPage);
        // Perform gRPC request
        const response = await this.grpcRequest(endpoint, requestData);
        const responseObject = response.toObject();
        // Check response status
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Listing failed with response ${response}`);
        return response;
    }
}







var $2453de9811f0eca7$var$PREFIX;
function $2453de9811f0eca7$export$8db309f08fe1953c(MessageType, data) {
    const instance = new MessageType();
    // Validate Missing props removed - not needed if we are targeting to convert partial objects to protobuf objects
    // validateMissingProps(instance, data);
    for (const [prop, value] of Object.entries($2453de9811f0eca7$var$filterExtraProps(instance, data))){
        if (Array.isArray(value) && $2453de9811f0eca7$var$isProtobufMap(instance, prop)) {
            const mapMethod = $2453de9811f0eca7$var$getMethod(prop, "get");
            const map = $2453de9811f0eca7$var$callMethod(instance, mapMethod);
            const NestedType = $2453de9811f0eca7$var$retrieveNestedMapTypePatch(instance, prop);
            for (const [k, v] of value){
                if (!$2453de9811f0eca7$var$isObject(v, prop)) {
                    map.set(k, v);
                    continue;
                }
                if (!NestedType) throw new Error("Unable to retrieve nested type");
                map.set(k, $2453de9811f0eca7$export$8db309f08fe1953c(NestedType, v));
            }
            continue;
        }
        const result = $2453de9811f0eca7$var$getResult(instance, prop, value);
        $2453de9811f0eca7$var$validateType(instance, prop, value);
        const setter = $2453de9811f0eca7$var$getMethod(prop, "set");
        $2453de9811f0eca7$var$callMethod(instance, setter, result);
    }
    return instance;
}
function $2453de9811f0eca7$var$getResult(instance, prop, value) {
    if (value instanceof Uint8Array) return value;
    if (Array.isArray(value)) {
        if (value.length === 0 || !$2453de9811f0eca7$var$isArrayOfObjects(value, prop)) return value;
        const NestedType = $2453de9811f0eca7$var$retrieveNestedRepeatedTypePatch(instance, prop);
        if (!NestedType) throw new Error("Unable to retrieve nested type");
        return value.map((child)=>$2453de9811f0eca7$export$8db309f08fe1953c(NestedType, child));
    }
    if ($2453de9811f0eca7$var$isObject(value, prop)) {
        const NestedType = $2453de9811f0eca7$var$retrieveNestedTypePatch(instance, prop);
        if (!NestedType) throw new Error("Unable to retrieve nested type");
        return $2453de9811f0eca7$export$8db309f08fe1953c(NestedType, value);
    }
    return value;
}
function $2453de9811f0eca7$var$callMethod(obj, key, value) {
    return obj[key](value);
}
function $2453de9811f0eca7$var$getProp(key, prefix) {
    const prop = key.slice(prefix.length);
    return prop.slice(0, 1).toLowerCase() + prop.slice(1);
}
function $2453de9811f0eca7$var$getMethod(prop, prefix) {
    return `${prefix}${prop[0].toUpperCase()}${prop.slice(1)}`;
}
function $2453de9811f0eca7$var$getInstancePropsFromKeys(keys, prefix) {
    return keys.filter((key)=>key.startsWith(prefix)).map((key)=>$2453de9811f0eca7$var$getProp(key, prefix));
}
function $2453de9811f0eca7$var$getInstanceProps(instance) {
    const keys = Object.keys(Object.getPrototypeOf(instance));
    const setters = $2453de9811f0eca7$var$getInstancePropsFromKeys(keys, "set");
    const maps = $2453de9811f0eca7$var$getInstancePropsFromKeys(keys, "clear").filter((prop)=>$2453de9811f0eca7$var$isProtobufMap(instance, prop));
    return [
        ...setters,
        ...maps
    ];
}
function $2453de9811f0eca7$var$isProtobufMap(instance, prop) {
    return $2453de9811f0eca7$var$callMethod(instance, $2453de9811f0eca7$var$getMethod(prop, "get")) instanceof (0, $hgUW1$Map);
}
function $2453de9811f0eca7$var$filterExtraProps(instance, data) {
    const instanceProps = $2453de9811f0eca7$var$getInstanceProps(instance);
    return Object.fromEntries(Object.entries(data).filter(([key, value])=>instanceProps.includes(key) && value !== undefined));
}
function $2453de9811f0eca7$var$isObject(value, prop) {
    if (value === null) throw new Error(`Null value for key '${prop}'`);
    return typeof value === "object";
}
function $2453de9811f0eca7$var$isArrayOfObjects(arr, prop) {
    if (arr.every((item)=>$2453de9811f0eca7$var$isObject(item, prop))) return true;
    if (arr.every((item)=>!$2453de9811f0eca7$var$isObject(item, prop))) return false;
    throw new Error(`Mixed array for '${prop}'`);
}
function $2453de9811f0eca7$var$validateType(instance, prop, value) {
    const getter = $2453de9811f0eca7$var$getMethod(prop, "get");
    const instanceValue = $2453de9811f0eca7$var$callMethod(instance, getter);
    const expectedType = instanceValue !== undefined ? typeof instanceValue : "object";
    const actualType = value instanceof Uint8Array ? "string" : typeof value;
    if (Array.isArray(instanceValue) && !Array.isArray(value)) throw new Error(`Invalid type for '${prop}' (expected array, got '${actualType}')`);
    if (!Array.isArray(instanceValue) && Array.isArray(value)) throw new Error(`Invalid type for '${prop}' (expected '${expectedType}', got array)`);
    if (expectedType !== actualType) throw new Error(`Invalid type for '${prop}' (expected '${expectedType}', got '${actualType}')`);
}
function $2453de9811f0eca7$var$retrieveNestedTypePatch(instance, prop) {
    const getWrapperField = (0, $hgUW1$Message).getWrapperField;
    let nestedType = null;
    (0, $hgUW1$Message).getWrapperField = function(msg, ctor, fieldNumber, required) {
        nestedType = ctor;
        return getWrapperField(msg, ctor, fieldNumber, required);
    };
    $2453de9811f0eca7$var$callMethod(instance, $2453de9811f0eca7$var$getMethod(prop, "get"));
    (0, $hgUW1$Message).getWrapperField = getWrapperField;
    return nestedType;
}
function $2453de9811f0eca7$var$retrieveNestedRepeatedTypePatch(instance, prop) {
    const getRepeatedWrapperField = (0, $hgUW1$Message).getRepeatedWrapperField;
    let nestedType = null;
    (0, $hgUW1$Message).getRepeatedWrapperField = function(msg, ctor, fieldNumber) {
        nestedType = ctor;
        return getRepeatedWrapperField(msg, ctor, fieldNumber);
    };
    $2453de9811f0eca7$var$callMethod(instance, $2453de9811f0eca7$var$getMethod(prop, "get"));
    (0, $hgUW1$Message).getRepeatedWrapperField = getRepeatedWrapperField;
    return nestedType;
}
function $2453de9811f0eca7$var$retrieveNestedMapTypePatch(instance, prop) {
    const getMapField = (0, $hgUW1$Message).getMapField;
    let nestedType = null;
    (0, $hgUW1$Message).getMapField = function(msg, fieldNumber, noLazyCreate, valueCtor) {
        nestedType = valueCtor ?? null;
        return getMapField(msg, fieldNumber, noLazyCreate, valueCtor);
    };
    $2453de9811f0eca7$var$callMethod(instance, $2453de9811f0eca7$var$getMethod(prop, "get"));
    (0, $hgUW1$Message).getMapField = getMapField;
    return nestedType;
}


class $1eac708f26a71747$export$1f44aaf2ec115b54 extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    /**
   * Initializes an User object with the specified authentication configuration.
   *
   * @param authConfig An object containing the authentication configuration. Defaults to an empty object.
   * @param authConfig.userId The user ID for the user to interact with.
   * @param authConfig.appId The application ID associated with the user.
   * @param authConfig.pat A personal access token for authentication. Can also be set as an environment variable CLARIFAI_PAT.
   * @param authConfig.token A session token for authentication. Accepts either a session token or a personal access token (pat). Can also be set as an environment variable CLARIFAI_SESSION_TOKEN.
   * @param authConfig.base Optional. The base API URL. Defaults to "https://api.clarifai.com".
   * @param authConfig.ui Optional. Additional UI configurations.
   *
   * @includeExample examples/user/index.ts
   */ constructor(authConfig = {}){
        super({
            authConfig: authConfig
        });
    }
    /**
   * Lists all the apps for the user.
   *
   * @param params A dictionary of filters to be applied to the list of apps.
   * @param pageNo The page number to list.
   * @param perPage The number of items per page.
   * @yields App objects for the user.
   *
   * @includeExample examples/user/listApps.ts
   *
   * @note Defaults to 16 per page if pageNo is specified and perPage is not specified.
   * If both pageNo and perPage are None, then lists all the resources.
   */ async *listApps({ params: params = {}, pageNo: pageNo, perPage: perPage } = {}) {
        const listApps = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listApps, this.STUB.client);
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListAppsRequest), params);
        for await (const item of this.listPagesGenerator(listApps, request, pageNo, perPage))yield item.toObject()?.appsList;
    }
    /**
   * Lists all the runners for the user.
   *
   * @param params A dictionary of filters to be applied to the list of runners.
   * @param pageNo The page number to list.
   * @param perPage The number of items per page.
   * @yields Runner objects for the user.
   *
   * @includeExample examples/user/listRunners.ts
   *
   * @note Defaults to 16 per page if perPage is not specified.
   */ async *listRunners({ params: params = {}, pageNo: pageNo, perPage: perPage } = {}) {
        const listRunners = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listRunners, this.STUB.client);
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListRunnersRequest), params);
        for await (const item of this.listPagesGenerator(listRunners, request, pageNo, perPage))yield item.toObject();
    }
    /**
   * Creates an app for the user.
   *
   * @param appId The app ID for the app to create.
   * @param baseWorkflow The base workflow to use for the app. Examples: 'Universal', 'Language-Understanding', 'General'
   * @returns An App object for the specified app ID.
   *
   * @includeExample examples/user/createApp.ts
   */ async createApp({ appId: appId, baseWorkflow: baseWorkflow = "Empty" }) {
        const workflow = new (0, $hgUW1$Workflow)();
        workflow.setId(baseWorkflow);
        workflow.setAppId("main");
        workflow.setUserId("clarifai");
        const app = new (0, $hgUW1$App)();
        app.setId(appId);
        app.setDefaultWorkflow(workflow);
        const request = new (0, $hgUW1$PostAppsRequest)();
        request.setUserAppId(this.userAppId);
        request.setAppsList([
            app
        ]);
        const postApps = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postApps, this.STUB.client);
        const response = await this.grpcRequest(postApps, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Failed to create app: ${responseObject.status?.description}`);
        return responseObject.appsList?.[0];
    }
    /**
   * Creates a runner for the user.
   *
   * @param runnerId The Id of runner to create.
   * @param labels Labels to match runner.
   * @param description Description of Runner.
   * @returns A runner object for the specified Runner ID.
   *
   * @includeExample examples/user/createRunner.ts
   */ async createRunner({ runnerId: runnerId, labels: labels, description: description }) {
        if (!Array.isArray(labels)) throw new Error("Labels must be an array of strings");
        const request = new (0, $hgUW1$PostRunnersRequest)();
        request.setUserAppId(this.userAppId);
        const runner = new (0, $hgUW1$Runner)();
        runner.setId(runnerId);
        runner.setLabelsList(labels);
        runner.setDescription(description);
        request.setRunnersList([
            runner
        ]);
        const postRunners = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postRunners, this.STUB.client);
        const response = await this.grpcRequest(postRunners, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Failed to create runner: ${responseObject.status?.description}`);
        console.info("\nRunner created\n%s", responseObject.status.description);
        return responseObject.runnersList?.[0];
    }
    /**
   * Returns an App object for the specified app ID.
   *
   * @param appId The app ID for the app to interact with.
   * @returns An App object for the specified app ID.
   *
   * @includeExample examples/user/app.ts
   */ async app({ appId: appId }) {
        const request = new (0, $hgUW1$GetAppRequest)();
        const appIdSet = new (0, $hgUW1$UserAppIDSet)();
        appIdSet.setUserId(this.userAppId.getUserId());
        appIdSet.setAppId(appId);
        request.setUserAppId(appIdSet);
        const getApp = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getApp, this.STUB.client);
        const response = await this.grpcRequest(getApp, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Failed to retrieve app: ${responseObject.status?.description}`);
        return responseObject["app"];
    }
    /**
   * Returns a Runner object if exists.
   *
   * @param runnerId The runner ID to interact with.
   * @returns A Runner object for the existing runner ID.
   *
   * @includeExample examples/user/runner.ts
   */ async runner({ runnerId: runnerId }) {
        const request = new (0, $hgUW1$GetRunnerRequest)();
        request.setUserAppId(this.userAppId);
        request.setRunnerId(runnerId);
        const getRunner = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getRunner, this.STUB.client);
        const response = await this.grpcRequest(getRunner, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Failed to retrieve runner: ${responseObject.status?.description}`);
        return responseObject.runner;
    }
    /**
   * Deletes an app for the user.
   *
   * @param appId The app ID for the app to delete.
   *
   * @example examples/user/deleteApp.ts
   */ async deleteApp({ appId: appId }) {
        const request = new (0, $hgUW1$DeleteAppRequest)();
        const appIdSet = new (0, $hgUW1$UserAppIDSet)();
        appIdSet.setUserId(this.userAppId.getUserId());
        appIdSet.setAppId(appId);
        request.setUserAppId(appIdSet);
        const deleteApp = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteApp, this.STUB.client);
        const response = await this.grpcRequest(deleteApp, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nApp Deleted\n%s", responseObject.status.description);
    }
    /**
   * Deletes a runner for the user.
   *
   * @param runnerId The runner ID to delete.
   *
   * @includeExample examples/user/deleteRunner.ts
   */ async deleteRunner({ runnerId: runnerId }) {
        const request = new (0, $hgUW1$DeleteRunnersRequest)();
        request.setUserAppId(this.userAppId);
        request.setIdsList([
            runnerId
        ]);
        const deleteRunners = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteRunners, this.STUB.client);
        const response = await this.grpcRequest(deleteRunners, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nRunner Deleted\n%s", responseObject.status.description);
    }
}


var $f0cf11edd3834060$exports = {};

$parcel$export($f0cf11edd3834060$exports, "App", () => $f0cf11edd3834060$export$86fbec116b87613f);



class $5c07194696316c57$export$4fa98284752ac8ab {
    /**
   * Creates an instance of ClarifaiUrlHelper.
   * @param auth A ClarifaiAuthHelper object.
   * @param moduleManagerImvId ID for the module manager install, default is "module_manager_install".
   */ constructor(auth, moduleManagerImvId = "module_manager_install"){
        this.auth = auth;
        this.moduleManagerImvId = moduleManagerImvId;
    }
    /**
   * Getter for the auth property.
   */ getAuth() {
        return this.auth;
    }
    /**
   * Constructs a URL for module UI based on given parameters.
   * @param userId User ID.
   * @param appId Application ID.
   * @param moduleId Module ID.
   * @param moduleVersionId Module Version ID.
   * @returns A string representing the module UI URL.
   */ moduleUiUrl(userId, appId, moduleId, moduleVersionId) {
        return `${this.auth.ui}/${userId}/${appId}/modules/${moduleId}/versions/${moduleVersionId}`;
    }
    /**
   * Constructs a URL for module installation UI.
   * @param destUserId Destination User ID.
   * @param destAppId Destination Application ID.
   * @param moduleUrl Module URL.
   * @returns A string representing the module install UI URL.
   */ moduleInstallUiUrl(destUserId, destAppId, moduleUrl) {
        return `${this.auth.ui}/${destUserId}/${destAppId}/installed_module_versions/${this.moduleManagerImvId}/install?install=${moduleUrl}`;
    }
    /**
   * Constructs a URL for IMV UI.
   * @param destUserId Destination User ID.
   * @param destAppId Destination Application ID.
   * @param imvId IMV ID.
   * @returns A string representing the IMV UI URL.
   */ imvUiUrl(destUserId, destAppId, imvId) {
        return `${this.auth.ui}/${destUserId}/${destAppId}/installed_module_versions/${imvId}`;
    }
    /**
   * Constructs a URL to the resource in the community.
   * @param userId User ID.
   * @param appId Application ID.
   * @param resourceType Type of resource.
   * @param resourceId Resource ID.
   * @param versionId (Optional) Version of the resource.
   * @returns A string representing the URL to the resource.
   */ clarifaiUrl(userId, appId, resourceType, resourceId, versionId) {
        const validTypes = [
            "modules",
            "models",
            "concepts",
            "inputs",
            "workflows",
            "tasks",
            "installed_module_versions"
        ];
        if (!validTypes.includes(resourceType)) throw new Error(`resourceType must be one of ${validTypes.join(", ")} but was ${resourceType}`);
        if (versionId === undefined) return `${this.auth.ui}/${userId}/${appId}/${resourceType}/${resourceId}`;
        return `${this.auth.ui}/${userId}/${appId}/${resourceType}/${resourceId}/versions/${versionId}`;
    }
    /**
   * Splits a Clarifai app URL into its component parts.
   * clarifai.com uses fully qualified urls to resources.
   * They are in the format of:
   * https://clarifai.com/{user_id}/{app_id}
   *
   * @param url The Clarifai app URL.
   * @returns A tuple containing userId and appId.
   */ static splitClarifaiAppUrl(url) {
        const o = new (0, $hgUW1$URL)(url);
        const parts = o.pathname.split("/").filter((part)=>part.length > 0);
        if (parts.length !== 2) throw new Error(`Provided url must have 2 parts after the domain name. The current parts are: ${parts}`);
        const [userId, appId] = parts;
        return [
            userId,
            appId
        ];
    }
    /**
   * Splits a Clarifai URL into its component parts, including optional resource version.
   * clarifai.com uses fully qualified urls to resources.
   * They are in the format of:
   * https://clarifai.com/{user_id}/{app_id}/{resource_type}/{resource_id}/{resource_version_type}/{resource_version_id}
   * Those last two are optional.
   *
   * @param url The Clarifai URL.
   * @returns A tuple containing userId, appId, resourceType, resourceId, and optionally resourceVersionId.
   */ static splitClarifaiUrl(url) {
        const o = new (0, $hgUW1$URL)(url);
        const parts = o.pathname.split("/").filter((part)=>part.length > 0);
        if (parts.length !== 4 && parts.length !== 6) throw new Error("Provided url must have 4 or 6 parts after the domain name.");
        const [userId, appId, resourceType, resourceId] = parts;
        const resourceVersionId = parts.length === 6 ? parts[5] : undefined;
        return [
            userId,
            appId,
            resourceType,
            resourceId,
            resourceVersionId
        ];
    }
    /**
   * Splits a module UI URL into its component IDs.
   * Takes in a path like https://clarifai.com/zeiler/app/modules/module1/versions/2 to split it apart into it's IDs.
   *
   * @param install The module UI URL.
   * @returns A tuple containing userId, appId, moduleId, and moduleVersionId.
   */ static splitModuleUiUrl(install) {
        const [userId, appId, resourceType, resourceId, resourceVersionId] = this.splitClarifaiUrl(install);
        if (resourceType !== "modules") throw new Error("Provided install url must be a module.");
        if (resourceVersionId === undefined) throw new Error("Provided install url must have 6 parts after the domain name.");
        return [
            userId,
            appId,
            resourceId,
            resourceVersionId
        ];
    }
}





const $f41a00b1177ea1b3$export$b8a4125304d344d = [
    "visual-classifier",
    "visual-detector",
    "visual-segmenter",
    "visual-embedder",
    "clusterer",
    "text-classifier",
    "embedding-classifier",
    "text-to-text"
];
const $f41a00b1177ea1b3$export$901647b676c334c2 = 128;






const $f58a83054e170fa6$var$idValidator = (0, $hgUW1$z).string().min(1).max(48).regex(/^[0-9A-Za-z]+([-_][0-9A-Za-z]+)*$/);
const $f58a83054e170fa6$var$hexIdValidator = (0, $hgUW1$z).preprocess((val)=>typeof val === "string" ? val.toLowerCase() : val, (0, $hgUW1$z).string().length(32).regex(/^[0-9a-f]{32}$/));
const $f58a83054e170fa6$var$modelDoesNotHaveModelVersionIdAndOtherFields = (model)=>{
    if (model.modelVersionId && $f58a83054e170fa6$var$modelHasOtherFields(model)) throw new Error(`model should not set modelVersionId and other model fields: ${JSON.stringify(model)}; please remove modelVersionId or other model fields.`);
    return true;
};
const $f58a83054e170fa6$var$modelHasOtherFields = (model)=>{
    return Object.keys(model).some((key)=>key !== "modelId" && key !== "modelVersionId");
};
const $f58a83054e170fa6$var$workflowNodesHaveValidDependencies = (nodes)=>{
    const nodeIds = new Set();
    for (const node of nodes){
        (node.nodeInputs || []).forEach((nodeInput)=>{
            if (!nodeIds.has(nodeInput.nodeId)) throw new Error(`missing input '${nodeInput.nodeId}' for node '${node.id}'`);
        });
        nodeIds.add(node.id);
    }
    return true;
};
const $f58a83054e170fa6$var$dataSchema = (0, $hgUW1$z).object({
    workflow: (0, $hgUW1$z).object({
        id: $f58a83054e170fa6$var$idValidator,
        nodes: (0, $hgUW1$z).array((0, $hgUW1$z).object({
            id: (0, $hgUW1$z).string().min(1),
            model: (0, $hgUW1$z).object({
                modelId: $f58a83054e170fa6$var$idValidator,
                appId: $f58a83054e170fa6$var$idValidator.optional(),
                userId: $f58a83054e170fa6$var$idValidator.optional(),
                modelVersionId: $f58a83054e170fa6$var$hexIdValidator.optional(),
                modelTypeId: $f58a83054e170fa6$var$idValidator.optional(),
                description: (0, $hgUW1$z).string().optional(),
                outputInfo: (0, $hgUW1$z).object({
                    params: (0, $hgUW1$z).record((0, $hgUW1$z).any()).optional()
                }).optional()
            }).refine($f58a83054e170fa6$var$modelDoesNotHaveModelVersionIdAndOtherFields),
            nodeInputs: (0, $hgUW1$z).array((0, $hgUW1$z).object({
                nodeId: (0, $hgUW1$z).string().min(1)
            })).optional()
        })).refine($f58a83054e170fa6$var$workflowNodesHaveValidDependencies)
    })
});
const $f58a83054e170fa6$export$8e5c4bbe6bcfd175 = (data)=>{
    return $f58a83054e170fa6$var$dataSchema.parse(data);
};




function $a3ecf8aee6db342a$export$b4483c4bf292a57b(yamlModelOutputInfo) {
    if (!yamlModelOutputInfo?.params) return undefined;
    return new (0, $hgUW1$OutputInfo)().setParams($a3ecf8aee6db342a$var$convertYamlParamsToApiParams(yamlModelOutputInfo.params));
}
function $a3ecf8aee6db342a$var$convertYamlParamsToApiParams(yamlParams) {
    if (!yamlParams) return undefined;
    return (0, $hgUW1$Struct).fromJavaScript(yamlParams);
}
function $a3ecf8aee6db342a$export$555b6370e992353a(apiModel, yamlModel) {
    const yamlModelFromApi = {};
    for (const [key] of Object.entries(yamlModel))if (key === "outputInfo" && apiModel.modelVersion?.outputInfo?.params) yamlModelFromApi[key] = {
        params: apiModel.modelVersion.outputInfo.params
    };
    else // @ts-expect-error - key will be available in apiModelObject
    yamlModelFromApi[key] = apiModel?.[key];
    yamlModelFromApi.modelId = apiModel.id;
    const ignoreKeys = new Set();
    return $a3ecf8aee6db342a$var$isDictInDict(yamlModel, yamlModelFromApi, ignoreKeys);
}
function $a3ecf8aee6db342a$var$isDictInDict(dictionary1, dictionary2, ignoreKeys) {
    for (const [key, value] of Object.entries(dictionary1)){
        if (ignoreKeys && ignoreKeys.has(key)) continue;
        if (!(key in dictionary2)) return false;
        if (typeof value === "object" && value !== null) {
            if (typeof dictionary2[key] !== "object" || dictionary2[key] === null) return false;
            return $a3ecf8aee6db342a$var$isDictInDict(value, dictionary2[key]);
        } else if (value !== dictionary2[key]) return false;
    }
    return true;
}


var $2e0e50b57c59b46b$exports = {};

$parcel$export($2e0e50b57c59b46b$exports, "Model", () => $2e0e50b57c59b46b$export$a1edc412be3e1841);









function $c5b83c229c6228d6$export$9238ec863a39c431(response, modelTypeId) {
    let templates = [];
    for (const modelType of response.modelTypesList)if (modelType.id === modelTypeId) {
        for (const modelTypeField of modelType.modelTypeFieldsList)if (modelTypeField.path.split(".").pop() === "template") templates = modelTypeField.modelTypeEnumOptionsList.map((template)=>template.id);
    }
    return templates;
}
function $c5b83c229c6228d6$export$e4f3a56b61cc133f(response, modelTypeId, template = null) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const params = {};
    if (modelTypeId !== "clusterer") {
        params["dataset_id"] = "";
        params["dataset_version_id"] = "";
    }
    if (![
        "clusterer",
        "text-to-text"
    ].includes(modelTypeId)) params["concepts"] = [];
    params["train_params"] = {};
    for (const modelType of response.modelTypesList){
        if (modelType.id === modelTypeId) for (const modelTypeField of modelType.modelTypeFieldsList){
            const pathParts = modelTypeField.path.split(".");
            if (pathParts[0] === "'eval_info'" || pathParts[1] === "dataset" || pathParts[1] === "data" || pathParts[pathParts.length - 1] === "dataset_id" || pathParts[pathParts.length - 1] === "dataset_version_id" || modelTypeField.internalOnly) continue;
            if (pathParts[pathParts.length - 1] !== "template") {
                if (pathParts[0] === "train_info" || pathParts[0] === "input_info") params["train_params"][pathParts[pathParts.length - 1]] = modelTypeField.defaultValue ?? null;
                if (pathParts[0] === "output_info") {
                    params["inference_params"] = {};
                    params["inference_params"][pathParts[pathParts.length - 1]] = modelTypeField.defaultValue ?? null;
                }
            } else if (modelTypeField.modelTypeEnumOptionsList) {
                const allTemplates = modelTypeField.modelTypeEnumOptionsList.map((template)=>template.id);
                if (!allTemplates.includes(template)) throw new Error(`Invalid template ${template} for model type ${modelTypeId}. Valid templates are ${allTemplates}`);
                for (const modelTypeEnum of modelTypeField.modelTypeEnumOptionsList)if (modelTypeEnum.id === template) {
                    params["train_params"]["template"] = modelTypeEnum.id;
                    for (const modelTypeEnumField of modelTypeEnum.modelTypeFieldsList){
                        if (modelTypeEnumField.internalOnly) continue;
                        params["train_params"][modelTypeEnumField.path.split(".").pop()] = modelTypeEnumField.defaultValue ?? null;
                    }
                }
            }
        }
    }
    if ("custom_config" in params["train_params"]) {
        const filePath = params["train_params"]["template"] + ".py";
        (0, $hgUW1$writeFileSync)(filePath, params["train_params"]["custom_config"]);
        params["train_params"]["custom_config"] = filePath;
    }
    return params;
}
function $c5b83c229c6228d6$export$d72c8b3f2a052f23(nestedDict, targetKey, replacementValue) {
    Object.entries(nestedDict).forEach(([key, value])=>{
        if (key === targetKey) nestedDict[key] = replacementValue;
        else if (typeof value === "object" && value !== null && !Array.isArray(value)) $c5b83c229c6228d6$export$d72c8b3f2a052f23(value, targetKey, replacementValue);
    });
}
function $c5b83c229c6228d6$export$9746b090ca75fbd0(response, modelTypeId, param, template = null) {
    for (const modelType of response.modelTypesList){
        if (modelType.id === modelTypeId) // iterate through the model type fields
        for (const modelTypeField of modelType.modelTypeFieldsList){
            if (modelTypeField.path.split(".").pop() === param) {
                if (param === "template") {
                    // @ts-expect-error placehoder needs to be deleted
                    delete modelTypeField.placeholder;
                    // @ts-expect-error modelTypeEnumOptionsList needs to be deleted
                    delete modelTypeField.modelTypeEnumOptionsList;
                    return modelTypeField;
                }
                // @ts-expect-error params have to be attached to modelTypeField
                modelTypeField.param = modelTypeField.path.split(".").pop();
                // @ts-expect-error placehoder needs to be deleted
                delete modelTypeField.placeholder;
                return modelTypeField;
            }
            // checking the template model type fields
            if (modelTypeField.path.split(".").pop() === "template") {
                for (const modelTypeEnum of modelTypeField.modelTypeEnumOptionsList)if (modelTypeEnum.id === template) {
                    // iterate through the template fields
                    for (const modelTypeEnumField of modelTypeEnum.modelTypeFieldsList)if (modelTypeEnumField.path.split(".").pop() === param) {
                        // @ts-expect-error params have to be attached to modelTypeEnumField
                        modelTypeEnumField.param = modelTypeEnumField.path.split(".").pop();
                        // @ts-expect-error placehoder needs to be deleted
                        delete modelTypeEnumField.placeholder;
                        return modelTypeEnumField;
                    }
                }
            }
        }
    }
}




var $837b266c4810d7cb$exports = {};

$parcel$export($837b266c4810d7cb$exports, "Input", () => $837b266c4810d7cb$export$f5b8910cec6cf069);

















const $d61ff044f3dd6a6d$export$58e94870d0a43b0a = [
    "visual_classification",
    "text_classification",
    "visual_detection",
    "visual_segmentation",
    "visual_captioning"
];
const $d61ff044f3dd6a6d$export$bd74614aa365611 = {
    visual_classification: {
        concepts: "labels"
    },
    text_classification: {
        concepts: "labels"
    },
    visual_captioning: {
        concepts: "labels"
    },
    visual_detection: {
        bboxes: "bboxes"
    },
    visual_segmentation: {
        polygons: "polygons"
    }
};
const $d61ff044f3dd6a6d$export$1f86472c1374185a = 2;


class $837b266c4810d7cb$export$f5b8910cec6cf069 extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    /**
   * Initializes an input object.
   *
   * @param params - The parameters for the Input object.
   * @param params.userId - A user ID for authentication.
   * @param params.appId - An app ID for the application to interact with.
   * @param params.baseUrl - Base API url. Default "https://api.clarifai.com"
   * @param params.pat - A personal access token for authentication. Can be set as env var CLARIFAI_PAT
   * @param params.token - A session token for authentication. Accepts either a session token or a pat. Can be set as env var CLARIFAI_SESSION_TOKEN
   *
   * @includeExample examples/input/index.ts
   */ constructor({ authConfig: authConfig }){
        super({
            authConfig: authConfig
        });
        this.numOfWorkers = Math.min((0, $hgUW1$os).cpus().length, 10);
    }
    /**
   * Create input proto for image data type.
   *
   * @param inputId - The input ID for the input to create.
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @param imagePb - The image proto to be used for the input.
   * @param videoPb - The video proto to be used for the input.
   * @param audioPb - The audio proto to be used for the input.
   * @param textPb - The text proto to be used for the input.
   * @param geoInfo - A list of longitude and latitude for the geo point.
   * @param labels - A list of labels for the input.
   * @param metadata - A Struct of metadata for the input.
   * @returns - An Input object for the specified input ID.
   */ static getProto({ inputId: inputId, datasetId: datasetId = null, imagePb: imagePb = null, videoPb: videoPb = null, audioPb: audioPb = null, textPb: textPb = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        const geoInfoSchema = (0, $hgUW1$z).array((0, $hgUW1$z).object({
            latitude: (0, $hgUW1$z).number(),
            longitude: (0, $hgUW1$z).number()
        })).or((0, $hgUW1$z).null());
        const labelsSchema = (0, $hgUW1$z).array((0, $hgUW1$z).string()).or((0, $hgUW1$z).null());
        const metaDataSchema = (0, $hgUW1$z).record((0, $hgUW1$z).string(), (0, $hgUW1$z).unknown()).or((0, $hgUW1$z).null());
        try {
            geoInfoSchema.parse(geoInfo);
        } catch  {
            throw new Error("geoInfo must be a list of longitude and latitude");
        }
        try {
            labelsSchema.parse(labels);
        } catch  {
            throw new Error("labels must be a list of strings");
        }
        try {
            metaDataSchema.parse(metadata);
        } catch  {
            throw new Error("metadata must be a valid object");
        }
        const metadataStruct = metadata ? (0, $hgUW1$Struct).fromJavaScript(metadata) : undefined;
        const geoPb = geoInfo ? new (0, $hgUW1$Geo)().setGeoPoint(new (0, $hgUW1$GeoPoint)().setLatitude(geoInfo.latitude).setLongitude(geoInfo.longitude)) : undefined;
        const concepts = labels?.map((_label)=>{
            return new (0, $hgUW1$Concept)().setId(`id-${_label.replace(/\s/g, "")}`).setName(_label).setValue(1);
        }) ?? [];
        const input = new (0, $hgUW1$Input)().setId(inputId).setData(new (0, $hgUW1$Data)().setImage(imagePb ? imagePb.base64 ? new (0, $hgUW1$Image)().setBase64(imagePb.base64) : imagePb.url ? new (0, $hgUW1$Image)().setUrl(imagePb.url) : undefined : undefined).setVideo(videoPb ? new (0, $hgUW1$Video)().setBase64(videoPb.base64) : undefined).setAudio(audioPb ? new (0, $hgUW1$Audio)().setBase64(audioPb.base64) : undefined).setText(textPb ? new (0, $hgUW1$Text)().setRaw(textPb.raw) : undefined).setGeo(geoPb).setConceptsList(concepts).setMetadata(metadataStruct));
        if (datasetId) input.setDatasetIdsList([
            datasetId
        ]);
        return input;
    }
    /**
   * Creates an input proto from bytes.
   *
   * @param inputId - The input ID for the input to create.
   * @param imageBytes - The bytes for the image as `Uint8Array` or `null`.
   * @param videoBytes - The bytes for the video as `Uint8Array` or `null`.
   * @param audioBytes - The bytes for the audio as `Uint8Array` or `null`.
   * @param textBytes - The bytes for the text as `Uint8Array` or `null`.
   * @param datasetId - The dataset ID for the dataset to add the input to, can be `null`.
   * @returns An `Input` object for the specified input ID.
   *
   * @includeExample examples/input/getInputFromBytes.ts
   */ static getInputFromBytes({ inputId: inputId, imageBytes: imageBytes = null, videoBytes: videoBytes = null, audioBytes: audioBytes = null, textBytes: textBytes = null, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        if (!(imageBytes || videoBytes || audioBytes || textBytes)) throw new Error("At least one of image_bytes, video_bytes, audio_bytes, text_bytes must be provided.");
        const imagePb = imageBytes ? {
            base64: (0, $hgUW1$Buffer).from(imageBytes).toString("base64")
        } : null;
        const videoPb = videoBytes ? {
            base64: (0, $hgUW1$Buffer).from(videoBytes).toString("base64")
        } : null;
        const audioPb = audioBytes ? {
            base64: (0, $hgUW1$Buffer).from(audioBytes).toString("base64")
        } : null;
        const textPb = textBytes ? {
            raw: (0, $hgUW1$Buffer).from(textBytes).toString("utf-8")
        } : null;
        return this.getProto({
            inputId: inputId,
            datasetId: datasetId,
            imagePb: imagePb,
            videoPb: videoPb,
            audioPb: audioPb,
            textPb: textPb,
            geoInfo: geoInfo,
            labels: labels,
            metadata: metadata
        });
    }
    /**
   * Create input proto from files.
   *
   * @param inputId - The input ID for the input to create.
   * @param imageFile - The file path for the image.
   * @param videoFile - The file path for the video.
   * @param audioFile - The file path for the audio.
   * @param textFile - The file path for the text.
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @returns - An Input object for the specified input ID.
   *
   * @includeExample examples/input/getInputFromFile.ts
   */ static getInputFromFile({ inputId: inputId, imageFile: imageFile = null, videoFile: videoFile = null, audioFile: audioFile = null, textFile: textFile = null, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        if (!(imageFile || videoFile || audioFile || textFile)) throw new Error("At least one of imageFile, videoFile, audioFile, textFile must be provided.");
        const imagePb = imageFile ? {
            base64: (0, $hgUW1$Buffer).from((0, $hgUW1$fs).readFileSync(imageFile)).toString("base64")
        } : null;
        const videoPb = videoFile ? {
            base64: (0, $hgUW1$Buffer).from((0, $hgUW1$fs).readFileSync(videoFile)).toString("base64")
        } : null;
        const audioPb = audioFile ? {
            base64: (0, $hgUW1$Buffer).from((0, $hgUW1$fs).readFileSync(audioFile)).toString("base64")
        } : null;
        const textPb = textFile ? {
            raw: (0, $hgUW1$fs).readFileSync(textFile, "utf-8")
        } : null;
        return this.getProto({
            inputId: inputId,
            datasetId: datasetId,
            imagePb: imagePb,
            videoPb: videoPb,
            audioPb: audioPb,
            textPb: textPb,
            geoInfo: geoInfo,
            labels: labels,
            metadata: metadata
        });
    }
    /**
   * Upload input from URL.
   *
   * @param inputId - The input ID for the input to create.
   * @param imageUrl - The URL for the image.
   * @param videoUrl - The URL for the video.
   * @param audioUrl - The URL for the audio.
   * @param textUrl - The URL for the text.
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @returns - Job ID for the upload request.
   *
   * @includeExample examples/input/getInputFromUrl.ts
   */ static getInputFromUrl({ inputId: inputId, imageUrl: imageUrl = null, videoUrl: videoUrl = null, audioUrl: audioUrl = null, textUrl: textUrl = null, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        if (!(imageUrl || videoUrl || audioUrl || textUrl)) throw new Error("At least one of imageUrl, videoUrl, audioUrl, textUrl must be provided.");
        const imagePb = imageUrl ? new (0, $hgUW1$Image)().setUrl(imageUrl) : null;
        const videoPb = videoUrl ? new (0, $hgUW1$Video)().setUrl(videoUrl) : null;
        const audioPb = audioUrl ? new (0, $hgUW1$Audio)().setUrl(audioUrl) : null;
        const textPb = textUrl ? new (0, $hgUW1$Text)().setUrl(textUrl) : null;
        const concepts = labels?.map((_label)=>{
            return new (0, $hgUW1$Concept)().setId(`id-${_label.replace(/\s/g, "")}`).setName(_label).setValue(1);
        }) ?? [];
        const metadataStruct = metadata ? (0, $hgUW1$Struct).fromJavaScript(metadata) : undefined;
        const input = new (0, $hgUW1$Input)().setId(inputId).setData(new (0, $hgUW1$Data)().setImage(imagePb ? imagePb : undefined).setVideo(videoPb ? videoPb : undefined).setAudio(audioPb ? audioPb : undefined).setText(textPb ? textPb : undefined).setGeo(geoInfo ? new (0, $hgUW1$Geo)().setGeoPoint(new (0, $hgUW1$GeoPoint)().setLatitude(geoInfo.latitude).setLongitude(geoInfo.longitude)) : undefined).setConceptsList(concepts).setMetadata(metadataStruct));
        if (datasetId) input.setDatasetIdsList([
            datasetId
        ]);
        return input;
    }
    /**
   * Upload image inputs from folder.
   *
   * @param folderPath - The path to the folder containing the images.
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @param labels - A boolean indicating whether to use the folder name as a label.
   *
   * @includeExample examples/input/getImageInputsFromFolder.ts
   */ static getImageInputsFromFolder({ folderPath: folderPath, datasetId: datasetId = null, labels: labels = false }) {
        const inputProtos = [];
        const folderName = folderPath.split("/").pop();
        const labelList = labels ? [
            folderName
        ] : null;
        (0, $hgUW1$fs).readdirSync(folderPath).forEach((filename)=>{
            const extension = filename.split(".").pop();
            if (extension && [
                "jpg",
                "jpeg",
                "png",
                "tiff",
                "webp"
            ].includes(extension.toLowerCase())) {
                const inputId = filename.split(".")[0];
                const imageBytes = (0, $hgUW1$fs).readFileSync((0, $hgUW1$path).join(folderPath, filename));
                const imagePb = {
                    base64: (0, $hgUW1$Buffer).from(imageBytes).toString("base64")
                };
                const inputProto = $837b266c4810d7cb$export$f5b8910cec6cf069.getProto({
                    inputId: inputId,
                    datasetId: datasetId,
                    imagePb: imagePb,
                    labels: labelList
                });
                inputProtos.push(inputProto);
            }
        });
        return inputProtos;
    }
    /**
   * Create input proto for text data type from raw text.
   *
   * @param inputId - The input ID for the input to create.
   * @param rawText - The raw text input.
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @returns - An Input object for the specified input ID.
   *
   * @includeExample examples/input/getTextInput.ts
   */ static getTextInput({ inputId: inputId, rawText: rawText, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        const textPb = rawText ? {
            raw: rawText
        } : null;
        return this.getProto({
            inputId: inputId,
            datasetId: datasetId,
            textPb: textPb,
            geoInfo: geoInfo,
            labels: labels,
            metadata: metadata
        });
    }
    /**
   * Create input proto for text and image from bytes or url
   *
   * @param inputId - The input ID for the input to create.
   * @param rawText - The raw text input.
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @param textBytes - The bytes for the text as `Uint8Array` or `Buffer`.
   * @param imageUrl - The URL for the image.
   * @param imageBytes - The bytes for the image as `Uint8Array` or `Buffer`.
   * @returns - An Input object for the specified input ID.
   */ static getMultimodalInput({ inputId: inputId, rawText: rawText = null, textBytes: textBytes = null, imageUrl: imageUrl = null, imageBytes: imageBytes = null, datasetId: datasetId = null, labels: labels = null }) {
        if (imageBytes && imageUrl || !imageBytes && !imageUrl) throw new Error("Please supply only one of imageBytes or imageUrl, and not both.");
        if (textBytes && rawText || !textBytes && !rawText) throw new Error("Please supply only one of textBytes or rawText, and not both.");
        const imagePb = imageBytes ? {
            base64: (0, $hgUW1$Buffer).from(imageBytes).toString("base64")
        } : imageUrl ? {
            url: imageUrl
        } : null;
        const textPb = textBytes ? {
            raw: (0, $hgUW1$Buffer).from(textBytes).toString("utf-8")
        } : rawText ? {
            raw: rawText
        } : null;
        return $837b266c4810d7cb$export$f5b8910cec6cf069.getProto({
            inputId: inputId,
            datasetId: datasetId,
            imagePb: imagePb,
            textPb: textPb,
            labels: labels
        });
    }
    /**
   * Create Input proto from CSV File. Supported columns are:
   * 'inputid', 'input', 'concepts', 'metadata', 'geopoints'
   *
   * @param csvPath - The path to the CSV file.
   * @param inputType - The type of input to create. Can be "text", "image", "video", or "audio".
   * @param csvType - The type of CSV file. Can be "raw", "url", or "file".
   * @param datasetId - The dataset ID for the dataset to add the input to.
   * @param labels - A boolean indicating whether to generate labels from concepts list.
   *
   * @returns - An array of Input objects for the specified input ID.
   */ static async getInputsFromCsv({ csvPath: csvPath, inputType: inputType = "text", csvType: csvType = "raw", datasetId: datasetId = null, labels: labels = true }) {
        const inputProtos = [];
        const csvData = await (0, $hgUW1$fs).promises.readFile(csvPath, "utf8");
        const parser = (0, $hgUW1$parse)(csvData, {
            columns: true
        });
        const records = [];
        parser.on("readable", function() {
            let record;
            while((record = parser.read()) !== null)// individual record
            records.push(record);
        });
        await (0, $hgUW1$finished)(parser);
        for (const record of records){
            const { inputid: inputid, input: input, concepts: concepts, metadata: metadata, geopoints: geopoints, ...otherColumns } = record;
            if (Object.keys(otherColumns).length > 0) throw new Error(`CSV file may have 'inputid', 'input', 'concepts', 'metadata', 'geopoints' columns. Does not support: '${Object.keys(otherColumns).join(", ")}'`);
            const inputLabels = labels ? concepts.split(",") : null;
            let inputMetadata = null;
            if (metadata) try {
                // TODO: Test CSV parsing of json values with actual test cases
                const metadataDict = JSON.parse(metadata.replace(/'/g, '"'));
                inputMetadata = {
                    fields: metadataDict
                };
            } catch (error) {
                throw new Error("metadata column in CSV file should be a valid JSON");
            }
            let inputGeoInfo = null;
            if (geopoints) {
                const geoPoints = geopoints.split(",");
                if (geoPoints.length === 2) inputGeoInfo = {
                    latitude: parseFloat(geoPoints[0]),
                    longitude: parseFloat(geoPoints[1])
                };
                else throw new Error("geopoints column in CSV file should have longitude,latitude");
            }
            const inputId = inputid || (0, $hgUW1$v4)();
            const text = inputType === "text" ? input : null;
            const image = inputType === "image" ? input : null;
            const video = inputType === "video" ? input : null;
            const audio = inputType === "audio" ? input : null;
            if (csvType === "raw") inputProtos.push($837b266c4810d7cb$export$f5b8910cec6cf069.getTextInput({
                inputId: inputId,
                rawText: text,
                datasetId: datasetId,
                labels: inputLabels,
                metadata: inputMetadata,
                geoInfo: inputGeoInfo
            }));
            else if (csvType === "url") inputProtos.push($837b266c4810d7cb$export$f5b8910cec6cf069.getInputFromUrl({
                inputId: inputId,
                imageUrl: image,
                textUrl: text,
                audioUrl: audio,
                videoUrl: video,
                datasetId: datasetId,
                labels: inputLabels,
                metadata: inputMetadata,
                geoInfo: inputGeoInfo
            }));
            else inputProtos.push($837b266c4810d7cb$export$f5b8910cec6cf069.getInputFromFile({
                inputId: inputId,
                imageFile: image,
                textFile: text,
                audioFile: audio,
                videoFile: video,
                datasetId: datasetId,
                labels: inputLabels,
                metadata: inputMetadata,
                geoInfo: inputGeoInfo
            }));
        }
        return inputProtos;
    }
    static getTextInputsFromFolder({ folderPath: folderPath, datasetId: datasetId = null, labels: labels = false }) {
        const inputProtos = [];
        const labelList = labels ? [
            folderPath.split("/").pop()
        ] : null;
        const files = (0, $hgUW1$fs).readdirSync(folderPath);
        for (const filename of files){
            if (filename.split(".").pop() !== "txt") continue;
            const inputId = filename.split(".")[0];
            const rawText = (0, $hgUW1$fs).readFileSync((0, $hgUW1$path).join(folderPath, filename), "utf8");
            const textPb = {
                raw: rawText
            };
            inputProtos.push($837b266c4810d7cb$export$f5b8910cec6cf069.getProto({
                inputId: inputId,
                datasetId: datasetId,
                textPb: textPb,
                labels: labelList
            }));
        }
        return inputProtos;
    }
    static getBboxProto({ inputId: inputId, label: label, bbox: bbox }) {
        const bboxSchema = (0, $hgUW1$z).array((0, $hgUW1$z).number()).length(4);
        try {
            bboxSchema.parse(bbox);
        } catch  {
            throw new Error("bbox must be an array of coordinates");
        }
        const [xMin, yMin, xMax, yMax] = bbox;
        const inputAnnotProto = new (0, $hgUW1$Annotation)().setInputId(inputId).setData(new (0, $hgUW1$Data)().setRegionsList([
            new (0, $hgUW1$Region)().setRegionInfo(new (0, $hgUW1$RegionInfo)().setBoundingBox(new (0, $hgUW1$BoundingBox)().setTopRow(yMin).setLeftCol(xMin).setBottomRow(yMax).setRightCol(xMax))).setData(new (0, $hgUW1$Data)().setConceptsList([
                new (0, $hgUW1$Concept)().setId(`id-${label.replace(/\s/g, "")}`).setName(label).setValue(1)
            ]))
        ]));
        return inputAnnotProto;
    }
    static getMaskProto({ inputId: inputId, label: label, polygons: polygons }) {
        const polygonsSchema = (0, $hgUW1$z).array((0, $hgUW1$z).array((0, $hgUW1$z).tuple([
            (0, $hgUW1$z).number(),
            (0, $hgUW1$z).number()
        ])));
        try {
            polygonsSchema.parse(polygons);
        } catch  {
            throw new Error("polygons must be a list of points");
        }
        const regions = polygons.map((points)=>{
            return new (0, $hgUW1$Region)().setRegionInfo(new (0, $hgUW1$RegionInfo)().setPolygon(new (0, $hgUW1$Polygon)().setPointsList(points.map((point)=>{
                return new (0, $hgUW1$Point)().setRow(point[1]).setCol(point[0]).setVisibility((0, $hgUW1$Point).Visibility["VISIBLE"]);
            })))).setData(new (0, $hgUW1$Data)().setConceptsList([
                new (0, $hgUW1$Concept)().setId(`id-${label.replace(/\s/g, "")}`).setName(label).setValue(1)
            ]));
        });
        const inputMaskProto = new (0, $hgUW1$Annotation)().setInputId(inputId).setData(new (0, $hgUW1$Data)().setRegionsList(regions));
        return inputMaskProto;
    }
    async uploadInputs({ inputs: inputs, showLog: showLog = true }) {
        if (!Array.isArray(inputs)) throw new Error("inputs must be an array of Input objects");
        const inputJobId = (0, $hgUW1$v4)(); // generate a unique id for this job
        const request = new (0, $hgUW1$PostInputsRequest)().setUserAppId(this.userAppId).setInputsList(inputs).setInputsAddJobId(inputJobId);
        const postInputs = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postInputs, this.STUB.client);
        const response = await this.grpcRequest(postInputs, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) {
            if (showLog) console.warn(responseObject.status?.description);
            throw new Error(`Inputs upload failed with response ${responseObject.status?.description}`);
        } else if (showLog) console.info("\nInputs Uploaded\n%s", responseObject.status?.description);
        return inputJobId;
    }
    uploadFromUrl({ inputId: inputId, imageUrl: imageUrl = null, videoUrl: videoUrl = null, audioUrl: audioUrl = null, textUrl: textUrl = null, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        const inputPb = $837b266c4810d7cb$export$f5b8910cec6cf069.getInputFromUrl({
            inputId: inputId,
            imageUrl: imageUrl,
            videoUrl: videoUrl,
            audioUrl: audioUrl,
            textUrl: textUrl,
            datasetId: datasetId,
            geoInfo: geoInfo,
            labels: labels,
            metadata: metadata
        });
        return this.uploadInputs({
            inputs: [
                inputPb
            ]
        });
    }
    uploadFromFile({ inputId: inputId, imageFile: imageFile = null, videoFile: videoFile = null, audioFile: audioFile = null, textFile: textFile = null, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        const inputProto = $837b266c4810d7cb$export$f5b8910cec6cf069.getInputFromFile({
            inputId: inputId,
            imageFile: imageFile,
            videoFile: videoFile,
            audioFile: audioFile,
            textFile: textFile,
            datasetId: datasetId,
            geoInfo: geoInfo,
            labels: labels,
            metadata: metadata
        });
        return this.uploadInputs({
            inputs: [
                inputProto
            ]
        });
    }
    uploadFromBytes({ inputId: inputId, imageBytes: imageBytes = null, videoBytes: videoBytes = null, audioBytes: audioBytes = null, textBytes: textBytes = null, datasetId: datasetId = null, geoInfo: geoInfo = null, labels: labels = null, metadata: metadata = null }) {
        const inputProto = $837b266c4810d7cb$export$f5b8910cec6cf069.getInputFromBytes({
            inputId: inputId,
            imageBytes: imageBytes,
            videoBytes: videoBytes,
            audioBytes: audioBytes,
            textBytes: textBytes,
            datasetId: datasetId,
            geoInfo: geoInfo,
            labels: labels,
            metadata: metadata
        });
        return this.uploadInputs({
            inputs: [
                inputProto
            ]
        });
    }
    uploadText({ inputId: inputId, rawText: rawText, datasetId: datasetId = null }) {
        const inputPb = $837b266c4810d7cb$export$f5b8910cec6cf069.getProto({
            inputId: inputId,
            datasetId: datasetId,
            textPb: {
                raw: rawText
            }
        });
        return this.uploadInputs({
            inputs: [
                inputPb
            ]
        });
    }
    async patchInputs({ inputs: inputs, action: action = "merge" }) {
        if (!Array.isArray(inputs)) throw new Error("inputs must be an array of Input objects");
        const requestId = (0, $hgUW1$v4)(); // generate a unique id for this job
        const request = new (0, $hgUW1$PatchInputsRequest)().setUserAppId(this.userAppId).setInputsList(inputs).setAction(action);
        const patchInputs = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.patchInputs, this.STUB.client);
        const response = await this.grpcRequest(patchInputs, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) {
            console.warn(`Patch inputs failed, status: ${responseObject.status?.description}`);
            throw Error(`Patch inputs failed, status: ${responseObject.status?.description}`);
        }
        console.info("\nPatch Inputs Successful\n%s", responseObject.status?.description);
        return requestId;
    }
    async uploadAnnotations({ batchAnnot: batchAnnot, showLog: showLog = true }) {
        const retryUpload = []; // those that fail to upload are stored for retries
        const request = new (0, $hgUW1$PostAnnotationsRequest)().setUserAppId(this.userAppId).setAnnotationsList(batchAnnot);
        const postAnnotations = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postAnnotations, this.STUB.client);
        const response = await this.grpcRequest(postAnnotations, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) {
            console.warn(`Post annotations failed, status: ${responseObject.status?.description}`);
            retryUpload.push(...batchAnnot);
        } else if (showLog) console.info("\nAnnotations Uploaded\n%s", responseObject.status);
        return retryUpload;
    }
    bulkUpload({ inputs: inputs, batchSize: providedBatchSize = 128, uploadProgressEmitter: uploadProgressEmitter }) {
        const batchSize = Math.min(128, providedBatchSize);
        const chunkedInputs = (0, $hgUW1$lodashchunk)(inputs, batchSize);
        let currentProgress = 0;
        const total = chunkedInputs.length;
        uploadProgressEmitter?.emit("start", {
            current: currentProgress,
            total: total
        });
        return new Promise((resolve, reject)=>{
            (0, $hgUW1$async).mapLimit(chunkedInputs, this.numOfWorkers, (batchInputs, callback)=>{
                this.uploadBatch({
                    inputs: batchInputs
                }).then((failedInputs)=>{
                    this.retryUploads({
                        failedInputs: failedInputs
                    }).finally(()=>{
                        currentProgress++;
                        uploadProgressEmitter?.emit("progress", {
                            current: currentProgress,
                            total: total
                        });
                        callback(null, failedInputs);
                    });
                }).catch((err)=>{
                    callback(err);
                });
            }, (err)=>{
                if (err) {
                    console.error("Error processing batches", err);
                    uploadProgressEmitter?.emit("error");
                    reject(err);
                }
                uploadProgressEmitter?.emit("end", {
                    current: total,
                    total: total
                });
                console.log("All inputs processed");
                resolve();
            });
        });
    }
    async uploadBatch({ inputs: inputs }) {
        const inputJobId = await this.uploadInputs({
            inputs: inputs,
            showLog: false
        });
        await this.waitForInputs({
            inputJobId: inputJobId
        });
        const failedInputs = await this.deleteFailedInputs({
            inputs: inputs
        });
        return failedInputs;
    }
    async waitForInputs({ inputJobId: inputJobId }) {
        const backoffIterator = new (0, $199a96159c1768e2$export$8bd55c4683eb5fb0)({
            count: 10
        });
        let maxRetries = 10;
        const startTime = Date.now();
        const thirtyMinutes = 1800000;
        // eslint-disable-next-line no-constant-condition
        while(true){
            const getInputsAddJobRequest = new (0, $hgUW1$GetInputsAddJobRequest)().setUserAppId(this.userAppId).setId(inputJobId);
            const getInputsAddJob = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getInputsAddJob, this.STUB.client);
            const response = await this.grpcRequest(getInputsAddJob, getInputsAddJobRequest);
            if (Date.now() - startTime > thirtyMinutes || maxRetries === 0) {
                const cancelInputsAddJobRequest = new (0, $hgUW1$CancelInputsAddJobRequest)().setUserAppId(this.userAppId).setId(inputJobId);
                const cancelInputsAddJob = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.cancelInputsAddJob, this.STUB.client);
                // 30 minutes timeout
                await this.grpcRequest(cancelInputsAddJob, cancelInputsAddJobRequest); // Cancel Job
                return false;
            }
            const responseObject = response.toObject();
            if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) {
                maxRetries -= 1;
                console.warn(`Get input job failed, status: ${responseObject.status?.description}\n`);
                continue;
            }
            if (responseObject.inputsAddJob?.progress?.inProgressCount === 0 && responseObject.inputsAddJob.progress.pendingCount === 0) return true;
            else await new Promise((resolve)=>{
                setTimeout(resolve, backoffIterator.next().value * 300);
            });
        }
    }
    async deleteFailedInputs({ inputs: inputs }) {
        const inputIds = inputs.map((input)=>input.getId());
        const successStatus = new (0, $hgUW1$Status)().setCode((0, $hgUW1$StatusCode).INPUT_DOWNLOAD_SUCCESS);
        const request = new (0, $hgUW1$ListInputsRequest)();
        request.setIdsList(inputIds);
        request.setPerPage(inputIds.length);
        request.setUserAppId(this.userAppId);
        request.setStatus(successStatus);
        const listInputs = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listInputs, this.STUB.client);
        const response = await this.grpcRequest(listInputs, request);
        const responseObject = response.toObject();
        const successInputs = responseObject.inputsList || [];
        const successInputIds = successInputs.map((input)=>input.id);
        const failedInputs = inputs.filter((input)=>!successInputIds.includes(input.getId()));
        const deleteInputs = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteInputs, this.STUB.client);
        const deleteInputsRequest = new (0, $hgUW1$DeleteInputsRequest)().setUserAppId(this.userAppId).setIdsList(failedInputs.map((input)=>input.getId()));
        // Delete failed inputs
        await this.grpcRequest(deleteInputs, deleteInputsRequest);
        return failedInputs;
    }
    async retryUploads({ failedInputs: failedInputs }) {
        for(let retry = 0; retry < (0, $d61ff044f3dd6a6d$export$1f86472c1374185a); retry++)if (failedInputs.length > 0) {
            console.log(`Retrying upload for ${failedInputs.length} Failed inputs..\n`);
            failedInputs = await this.uploadBatch({
                inputs: failedInputs
            });
        }
        if (failedInputs.length > 0) console.log(`Failed to upload ${failedInputs.length} inputs..\n`);
    }
}




var $2e0e50b57c59b46b$require$Buffer = $hgUW1$Buffer;
const $2e0e50b57c59b46b$var$isModelConfigWithUrl = (config)=>{
    return config.url !== undefined;
};
class $2e0e50b57c59b46b$export$a1edc412be3e1841 extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    /**
   * Initializes a Model object.
   *
   * @param url - The URL to initialize the model object.
   * @param modelId - The Model ID to interact with.
   * @param modelVersion - The Model Version to interact with.
   * @param authConfig - Authentication configuration options.
   * @param authConfig.baseURL - Base API URL. Default is "https://api.clarifai.com".
   * @param authConfig.pat - A personal access token for authentication. Can be set as env var CLARIFAI_PAT.
   * @param authConfig.token - A session token for authentication. Accepts either a session token or a pat. Can be set as env var CLARIFAI_SESSION_TOKEN.
   *
   * @includeExample examples/model/index.ts
   */ constructor(config){
        const { modelId: modelId, modelVersion: modelVersion, modelUserAppId: modelUserAppId } = config;
        if (config.url && config.modelId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You can only specify one of url or model_id.");
        if (config.url && modelUserAppId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You can only specify one of url or modelUserAppId.");
        if (!config.url && !config.modelId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You must specify one of url or model_id.");
        let _authConfig, _destructuredModelId = "", _destructuredModelVersionId = undefined;
        if ($2e0e50b57c59b46b$var$isModelConfigWithUrl(config)) {
            const { url: url } = config;
            const [userId, appId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiUrl(url);
            [, , , _destructuredModelId, _destructuredModelVersionId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiUrl(url);
            _authConfig = config.authConfig ? {
                ...config.authConfig,
                userId: userId,
                appId: appId
            } : {
                userId: userId,
                appId: appId,
                pat: undefined
            };
        } else // if authconfig is undefined, we pick the values from env
        _authConfig = config.authConfig || {
            pat: undefined,
            userId: undefined,
            appId: undefined
        };
        super({
            authConfig: _authConfig
        });
        this.appId = _authConfig.appId;
        this.modelVersion = modelVersion || (_destructuredModelVersionId ? {
            id: _destructuredModelVersionId
        } : undefined);
        this.id = modelId || _destructuredModelId;
        this.modelInfo = new (0, $hgUW1$Model)();
        const grpcModelVersion = new (0, $hgUW1$ModelVersion)();
        if (this.modelVersion) grpcModelVersion.setId(this.modelVersion.id);
        this.modelInfo.setAppId(this.appId);
        this.modelInfo.setId(this.id);
        if (this.modelVersion) this.modelInfo.setModelVersion(grpcModelVersion);
        this.trainingParams = {};
        this.modelUserAppId = new (0, $hgUW1$UserAppIDSet)().setAppId(_authConfig.appId).setUserId(_authConfig.userId);
    }
    /**
   * Loads the current model info.
   * Usually called internally by other methods, to ensure the model info is loaded with latest data.
   */ async loadInfo() {
        const getModel = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getModel, this.STUB.client);
        const request = new (0, $hgUW1$GetModelRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        request.setModelId(this.id);
        if (this.modelVersion?.id) request.setVersionId(this.modelVersion.id);
        const response = await this.grpcRequest(getModel, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Failed to get model: ${responseObject.status} : ${responseObject.status?.description}`);
        this.modelInfo = new (0, $hgUW1$Model)();
        if (responseObject.model?.id) this.modelInfo.setId(responseObject.model?.id);
        if (responseObject.model?.appId) this.modelInfo.setAppId(responseObject.model?.id);
        const grpcModelVersion = new (0, $hgUW1$ModelVersion)();
        if (responseObject.model?.modelVersion?.id) grpcModelVersion.setId(responseObject.model?.modelVersion?.id);
        this.modelInfo.setModelVersion(grpcModelVersion);
    }
    /**
   * Lists all the training templates for the model type.
   * @returns - A promise that resolves to a list of training templates for the model type.
   *
   * @includeExample examples/model/listTrainingTemplates.ts
   */ async listTrainingTemplates() {
        if (!this.modelInfo.getModelTypeId()) await this.loadInfo();
        if (!(0, $f41a00b1177ea1b3$export$b8a4125304d344d).includes(this.modelInfo.getModelTypeId())) throw new Error(`Model type ${this.modelInfo.getModelTypeId()} is not trainable`);
        const request = new (0, $hgUW1$ListModelTypesRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        const listModelTypes = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listModelTypes, this.STUB.client);
        const response = await this.grpcRequest(listModelTypes, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.toString());
        const templates = (0, $c5b83c229c6228d6$export$9238ec863a39c431)(responseObject, this.modelInfo.getModelTypeId());
        return templates;
    }
    /**
   * Returns the model params for the model type as object & also writes to a yaml file
   * @param template - The training template to use for the model type.
   * @param saveTo - The file path to save the yaml file.
   * @returns - A promise that resolves to the model params for the model type.
   *
   * @includeExample examples/model/getParams.ts
   */ async getParams(template = null, saveTo = "params.yaml") {
        if (!this.modelInfo.getModelTypeId()) await this.loadInfo();
        if (!(0, $f41a00b1177ea1b3$export$b8a4125304d344d).includes(this.modelInfo.getModelTypeId())) throw new Error(`Model type ${this.modelInfo.getModelTypeId()} is not trainable`);
        if (template === null && ![
            "clusterer",
            "embedding-classifier"
        ].includes(this.modelInfo.getModelTypeId())) throw new Error(`Template should be provided for ${this.modelInfo.getModelTypeId()} model type`);
        if (template !== null && [
            "clusterer",
            "embedding-classifier"
        ].includes(this.modelInfo.getModelTypeId())) throw new Error(`Template should not be provided for ${this.modelInfo.getModelTypeId()} model type`);
        const request = new (0, $hgUW1$ListModelTypesRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        const listModelTypes = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listModelTypes, this.STUB.client);
        const response = await this.grpcRequest(listModelTypes, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.toString());
        const params = (0, $c5b83c229c6228d6$export$e4f3a56b61cc133f)(responseObject, this.modelInfo.getModelTypeId(), template);
        // yaml file
        if (!saveTo.endsWith(".yaml")) throw new Error("File extension should be .yaml");
        $hgUW1$writeFileSync(saveTo, $hgUW1$dump(params, {
            noRefs: true
        }));
        this.trainingParams = {
            ...this.trainingParams,
            ...params
        };
        return params;
    }
    /**
   * Updates the model params for the model.
   * @param modelParams - The model params to update.
   *
   * @includeExample examples/model/updateParams.ts
   */ updateParams(modelParams) {
        if (!(0, $f41a00b1177ea1b3$export$b8a4125304d344d).includes(this.modelInfo.getModelTypeId())) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Model type ${this.modelInfo.getModelTypeId()} is not trainable`);
        if (Object.keys(this.trainingParams).length === 0) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Run 'model.getParams' to get the params for the ${this.modelInfo.getModelTypeId()} model type`);
        const allKeys = [
            ...Object.keys(this.trainingParams),
            ...Object.values(this.trainingParams).filter((value)=>typeof value === "object").flatMap((value)=>Object.keys(value))
        ];
        if (!Object.keys(modelParams).every((key)=>allKeys.includes(key))) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid params");
        for (const [key, value] of Object.entries(modelParams))(0, $c5b83c229c6228d6$export$d72c8b3f2a052f23)(this.trainingParams, key, value);
    }
    /**
   * Returns the param info for the model.
   *
   * @includeExample examples/model/getParamInfo.ts
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async getParamInfo(param) {
        if (!(0, $f41a00b1177ea1b3$export$b8a4125304d344d).includes(this.modelInfo.getModelTypeId())) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Model type ${this.modelInfo.getModelTypeId()} is not trainable`);
        if (Object.keys(this.trainingParams).length === 0) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Run 'model.getParams' to get the params for the ${this.modelInfo.getModelTypeId()} model type`);
        const allKeys = [
            ...Object.keys(this.trainingParams),
            ...Object.values(this.trainingParams).filter((value)=>typeof value === "object").flatMap((value)=>Object.keys(value))
        ];
        if (!allKeys.includes(param)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Invalid param: '${param}' for model type '${this.modelInfo.getModelTypeId()}'`);
        const template = // @ts-expect-error - train_params isn't typed yet
        this.trainingParams?.["train_params"]?.["template"] ?? null;
        const request = new (0, $hgUW1$ListModelTypesRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        const listModelTypes = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listModelTypes, this.STUB.client);
        const response = await this.grpcRequest(listModelTypes, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.toString());
        const paramInfo = (0, $c5b83c229c6228d6$export$9746b090ca75fbd0)(responseObject, this.modelInfo.getModelTypeId(), param, template);
        if (!paramInfo) throw new Error("Failed to fetch params info");
        return paramInfo;
    }
    /**
   * Deletes a model version for the Model.
   *
   * @param versionId - The version ID to delete.
   *
   * @includeExample examples/model/deleteVersion.ts
   */ async deleteVersion(versionId) {
        const request = new (0, $hgUW1$DeleteModelVersionRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        request.setModelId(this.id);
        request.setVersionId(versionId);
        const deleteModelVersion = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteModelVersion, this.STUB.client);
        const response = await this.grpcRequest(deleteModelVersion, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.toString());
    }
    /**
   * Creates a model version for the Model.
   *
   * @includeExample examples/model/createVersion.ts
   */ async createVersion(modelVersion) {
        if (this.modelInfo.getModelTypeId() in (0, $f41a00b1177ea1b3$export$b8a4125304d344d)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`${this.modelInfo.getModelTypeId()} is a trainable model type. Use 'model.train()' to train the model`);
        const request = new (0, $hgUW1$PostModelVersionsRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        request.setModelId(this.id);
        request.setModelVersionsList([
            modelVersion
        ]);
        const postModelVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postModelVersions, this.STUB.client);
        const response = await this.grpcRequest(postModelVersions, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        return responseObject.model;
    }
    /**
   * Lists all the versions for the model.
   *
   * @includeExample examples/model/listVersions.ts
   *
   * @remarks
   * Defaults to 16 per page if pageNo is not specified
   */ async *listVersions({ pageNo: pageNo, perPage: perPage } = {}) {
        const request = new (0, $hgUW1$ListModelVersionsRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        request.setModelId(this.id);
        const listModelVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listModelVersions, this.STUB.client);
        const allModelVersionsInfo = this.listPagesGenerator(listModelVersions, request, perPage, pageNo);
        for await (const modelVersionInfo of allModelVersionsInfo)yield modelVersionInfo.toObject().modelVersionsList;
    }
    /**
   * Predicts the model based on the given inputs.
   * Use the `Input` module to create the input objects.
   *
   * @param inputs - The inputs to predict, must be less than 128.
   * @param inferenceParams - The inference params to override.
   * @param outputConfig - The output config to override.
   *  min_value (number) - The minimum value of the prediction confidence to filter.
   *  max_concepts (number) - The maximum number of concepts to return.
   *  select_concepts (Concept[]) - The concepts to select.
   *  sample_ms (number) - The number of milliseconds to sample.
   * @returns - A promise that resolves to the model prediction.
   *
   * @includeExample examples/model/predict.ts
   */ async predict({ inputs: inputs, inferenceParams: inferenceParams, outputConfig: outputConfig }) {
        if (!Array.isArray(inputs)) throw new Error("Invalid inputs, inputs must be an array of Input objects.");
        if (inputs.length > (0, $f41a00b1177ea1b3$export$901647b676c334c2)) throw new Error(`Too many inputs. Max is ${(0, $f41a00b1177ea1b3$export$901647b676c334c2)}.`);
        this.overrideModelVersion({
            inferenceParams: inferenceParams,
            outputConfig: outputConfig
        });
        const requestInputs = [];
        for (const input of inputs)requestInputs.push(input);
        const request = new (0, $hgUW1$PostModelOutputsRequest)();
        if (this.modelUserAppId) request.setUserAppId(this.modelUserAppId);
        else request.setUserAppId(this.userAppId);
        request.setModelId(this.id);
        if (this.modelVersion && this.modelVersion.id) request.setVersionId(this.modelVersion.id);
        request.setInputsList(requestInputs);
        request.setModel(this.modelInfo);
        const startTime = Date.now();
        const backoffIterator = new (0, $199a96159c1768e2$export$8bd55c4683eb5fb0)();
        return new Promise((resolve, reject)=>{
            const makeRequest = ()=>{
                const postModelOutputs = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postModelOutputs, this.STUB.client);
                this.grpcRequest(postModelOutputs, request).then((response)=>{
                    const responseObject = response.toObject();
                    if (responseObject.status?.code === (0, $hgUW1$StatusCode).MODEL_DEPLOYING && Date.now() - startTime < 600000) {
                        console.log(`${this.id} model is still deploying, please wait...`);
                        setTimeout(makeRequest, backoffIterator.next().value * 1000);
                    } else if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) reject(new Error(`Model Predict failed with response ${responseObject.status?.toString()}`));
                    else resolve(response.toObject().outputsList);
                }).catch((error)=>{
                    reject(new Error(`Model Predict failed with error: ${error.message}`));
                });
            };
            makeRequest();
        });
    }
    /**
   * Predicts the model based on the given inputs.
   * Inputs can be provided as a URL.
   * @param url - The URL of the input.
   * @param inputType - The type of the input. Can be "image", "text", "video", or "audio".
   * @param inferenceParams - The inference params to override.
   * @param outputConfig - The output config to override.
   * @returns - A promise that resolves to the model prediction.
   */ predictByUrl({ url: url, inputType: inputType, inferenceParams: inferenceParams, outputConfig: outputConfig }) {
        let inputProto;
        if (inputType === "image") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            imageUrl: url
        });
        else if (inputType === "text") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            textUrl: url
        });
        else if (inputType === "video") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            videoUrl: url
        });
        else if (inputType === "audio") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            audioUrl: url
        });
        else throw new Error(`Got input type ${inputType} but expected one of image, text, video, audio.`);
        return this.predict({
            inputs: [
                inputProto
            ],
            inferenceParams: inferenceParams,
            outputConfig: outputConfig
        });
    }
    /**
   * Predicts the model based on the given inputs.
   * Inputs can be provided as a filepath which can be read.
   * @param filepath - The filepath of the input.
   * @param inputType - The type of the input. Can be "image", "text", "video", or "audio".
   * @param inferenceParams - The inference params to override.
   * @param outputConfig - The output config to override.
   * @returns - A promise that resolves to the model prediction.
   */ predictByFilepath({ filepath: filepath, inputType: inputType, inferenceParams: inferenceParams, outputConfig: outputConfig }) {
        if (!$hgUW1$existsSync(filepath)) throw new Error("Invalid filepath.");
        const fileBuffer = $hgUW1$readFileSync(filepath);
        return this.predictByBytes({
            inputBytes: fileBuffer,
            inputType: inputType,
            inferenceParams: inferenceParams,
            outputConfig: outputConfig
        });
    }
    /**
   * Predicts the model based on the given inputs.
   * Inputs can be provided as a Buffer.
   * @param inputBytes - Input as a buffer.
   * @param inputType - The type of the input. Can be "image", "text", "video", or "audio".
   * @param inferenceParams - The inference params to override.
   * @param outputConfig - The output config to override.
   * @returns - A promise that resolves to the model prediction.
   */ predictByBytes({ inputBytes: inputBytes, inputType: inputType, inferenceParams: inferenceParams, outputConfig: outputConfig }) {
        if (!(inputBytes instanceof $2e0e50b57c59b46b$require$Buffer)) throw new Error("Invalid bytes.");
        let inputProto;
        if (inputType === "image") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            imageBytes: inputBytes
        });
        else if (inputType === "text") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            textBytes: inputBytes
        });
        else if (inputType === "video") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            videoBytes: inputBytes
        });
        else if (inputType === "audio") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            audioBytes: inputBytes
        });
        else throw new Error(`Got input type ${inputType} but expected one of image, text, video, audio.`);
        return this.predict({
            inputs: [
                inputProto
            ],
            inferenceParams: inferenceParams,
            outputConfig: outputConfig
        });
    }
    /**
   * Overrides the model version.
   *
   * @param inferenceParams - The inference params to override.
   * @param outputConfig - The output config to override.
   *   min_value (number) - The minimum value of the prediction confidence to filter.
   *   max_concepts (number) - The maximum number of concepts to return.
   *   select_concepts (Concept[]) - The concepts to select.
   *   sample_ms (number) - The number of milliseconds to sample.
   */ overrideModelVersion({ inferenceParams: inferenceParams, outputConfig: outputConfig }) {
        let currentModelVersion = this.modelInfo.getModelVersion();
        if (!currentModelVersion) currentModelVersion = new (0, $hgUW1$ModelVersion)();
        let currentOutputInfo = currentModelVersion?.getOutputInfo();
        if (!currentOutputInfo) currentOutputInfo = new (0, $hgUW1$OutputInfo)();
        if (outputConfig) {
            const newOutputInfo = currentOutputInfo.setOutputConfig(outputConfig);
            currentModelVersion?.setOutputInfo(newOutputInfo);
            this.modelInfo.setModelVersion(currentModelVersion);
        }
        const updatedModelVersion = this.modelInfo.getModelVersion();
        const updatedOutputInfo = updatedModelVersion?.getOutputInfo();
        if (updatedOutputInfo && inferenceParams) {
            const params = (0, $hgUW1$Struct).fromJavaScript(inferenceParams);
            updatedOutputInfo.setParams(params);
            updatedModelVersion?.setOutputInfo(updatedOutputInfo);
            this.modelInfo.setModelVersion(updatedModelVersion);
        }
    }
}






class $f0cf11edd3834060$export$86fbec116b87613f extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    /**
   * Initializes an App object.
   * @param config - The configuration object for the App.
   * @param config.url - The URL of the app.
   * @param config.authConfig.userId The user ID for the user to interact with.
   * @param config.authConfig.appId The application ID associated with the user. Not required if the URL is provided.
   * @param config.authConfig.pat A personal access token for authentication. Can also be set as an environment variable CLARIFAI_PAT.
   * @param config.authConfig.token A session token for authentication. Accepts either a session token or a personal access token (pat). Can also be set as an environment variable CLARIFAI_SESSION_TOKEN.
   * @param config.authConfig.base Optional. The base API URL. Defaults to "https://api.clarifai.com".
   * @param config.authConfig.ui Optional. Additional UI configurations.
   *
   * @includeExample examples/app/index.ts
   */ constructor({ url: url, authConfig: authConfig }){
        if (url && authConfig.appId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You can only specify one of url or app_id.");
        if (url) {
            const [userId, appId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiAppUrl(url);
            // @ts-expect-error - since url is parsed, we need to set appId here
            if (userId) authConfig.userId = userId;
            // @ts-expect-error - since url is parsed, we need to set appId here
            if (appId) authConfig.appId = appId;
        }
        super({
            authConfig: authConfig
        });
        this.appInfo = new (0, $hgUW1$App)();
        this.appInfo.setUserId(authConfig.userId);
        this.appInfo.setId(authConfig.appId);
        this.info = this.appInfo.toObject();
    }
    /**
   * Lists all the datasets for the app.
   *
   * @param pageNo - The page number to list.
   * @param perPage - The number of items per page.
   *
   * @yields Dataset - Dataset objects for the datasets in the app.
   *
   * @includeExample examples/app/listDatasets.ts
   *
   * @remarks
   * Defaults to 16 per page
   */ async *listDataSets({ params: params = {}, pageNo: pageNo, perPage: perPage } = {}) {
        const listDataSets = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listDatasets, this.STUB.client);
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListDatasetsRequest), params);
        request.setUserAppId(this.userAppId);
        for await (const item of this.listPagesGenerator(listDataSets, request, pageNo, perPage))yield item.toObject()?.datasetsList;
    }
    /**
   * Lists all the available models for the user.
   *
   * @param params - A object of filters to apply to the list of models.
   * @param onlyInApp - If True, only return models that are in the app.
   * @param pageNo - The page number to list.
   * @param perPage - The number of items per page.
   *
   * @includeExample examples/app/listModels.ts
   *
   * @remarks
   * Defaults to 16 per page
   */ async *listModels({ params: params = {}, onlyInApp: onlyInApp = true, pageNo: pageNo, perPage: perPage } = {}) {
        const listModels = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listModels, this.STUB.client);
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListModelsRequest), params);
        request.setUserAppId(this.userAppId);
        for await (const item of this.listPagesGenerator(listModels, request, pageNo, perPage)){
            const models = [];
            const modelsListResponse = item.toObject();
            for (const eachModel of modelsListResponse.modelsList){
                if (!eachModel.modelVersion) continue;
                if (onlyInApp && eachModel.modelVersion.appId !== this.userAppId.getAppId()) continue;
                models.push(eachModel);
            }
            yield models;
        }
    }
    /**
   * Lists all the available workflows for the user.
   *
   * @param params - A object of filters to apply to the list of workflows.
   * @param onlyInApp - If True, only return workflows that are in the app.
   * @param pageNo - The page number to list.
   * @param perPage - The number of items per page.
   *
   * @yields Workflow - Workflow objects for the workflows in the app.
   *
   * @includeExample examples/app/listWorkflows.ts
   *
   * @remarks
   * Defaults to 16 per page
   */ async *listWorkflows({ params: params = {}, onlyInApp: onlyInApp = true, pageNo: pageNo, perPage: perPage } = {}) {
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListWorkflowsRequest), params);
        const listWorkflows = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listWorkflows, this.STUB.client);
        const listWorkflowsGenerator = this.listPagesGenerator(listWorkflows, request, pageNo, perPage);
        for await (const workflow of listWorkflowsGenerator){
            const workflows = [];
            const workflowObject = workflow.toObject();
            for (const eachWorkflow of workflowObject.workflowsList){
                if (onlyInApp && eachWorkflow.appId !== this.userAppId.getAppId()) continue;
                workflows.push(eachWorkflow);
            }
            yield workflows;
        }
    }
    /**
   * Lists all the available modules for the user.
   *
   * @param params - An object of filters to apply to the list of modules.
   * @param onlyInApp - If true, only return modules that are in the app.
   * @param pageNo - The page number to list.
   * @param perPage - The number of items per page.
   *
   * @yields Module - Module objects for the modules in the app.
   *
   * @includeExample examples/app/listModules.ts
   *
   * @remarks
   * Defaults to 16 per page
   */ async *listModules({ params: params = {}, onlyInApp: onlyInApp, pageNo: pageNo, perPage: perPage } = {}) {
        const listModules = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listModules, this.STUB.client);
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListModulesRequest), params);
        request.setUserAppId(this.userAppId);
        for await (const item of this.listPagesGenerator(listModules, request, pageNo, perPage)){
            const modules = [];
            const modulesListResponse = item.toObject();
            for (const eachModule of modulesListResponse.modulesList){
                if (onlyInApp && eachModule.appId !== this.userAppId.getAppId()) continue;
                modules.push(eachModule);
            }
            yield modules;
        }
    }
    /**
   * Lists all installed module versions in the app.
   *
   * @param params - A dictionary of filters to apply to the list of installed module versions.
   * @param pageNo - The page number to list.
   * @param perPage - The number of items per page.
   *
   * @yields Module - Module objects for the installed module versions in the app.
   *
   * @includeExample examples/app/listInstalledModuleVersions.ts
   *
   * @remarks
   * Defaults to 16 per page
   */ async *listInstalledModuleVersions({ params: params = {}, pageNo: pageNo, perPage: perPage } = {}) {
        const listInstalledModuleVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listInstalledModuleVersions, this.STUB.client);
        const request = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$ListInstalledModuleVersionsRequest), params);
        request.setUserAppId(this.userAppId);
        for await (const item of this.listPagesGenerator(listInstalledModuleVersions, request, pageNo, perPage)){
            const moduleVersions = [];
            const modulesListResponseObject = item.toObject();
            for (const eachModule of modulesListResponseObject.installedModuleVersionsList){
                // @ts-expect-error - delete needed here due to debt in the backend
                delete eachModule.deployUrl;
                // @ts-expect-error - delete needed here due to debt in the backend
                delete eachModule.installedModuleVersionId; // TODO: remove this after the backend fix
                moduleVersions.push(eachModule);
            }
            yield moduleVersions;
        }
    }
    /**
   * Lists all the concepts for the app.
   * @param page_no - The page number to list.
   * @param per_page - The number of items per page.
   * @yields Concepts in the app.
   *
   * @includeExample examples/app/listConcepts.ts
   */ async *listConcepts({ pageNo: pageNo, perPage: perPage } = {}) {
        const listConcepts = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listConcepts, this.STUB.client);
        const request = new (0, $hgUW1$ListConceptsRequest)();
        request.setUserAppId(this.userAppId);
        for await (const item of this.listPagesGenerator(listConcepts, request, pageNo, perPage)){
            const conceptsListResponse = item.toObject();
            yield conceptsListResponse.conceptsList;
        }
    }
    listTrainableModelTypes() {
        return 0, $f41a00b1177ea1b3$export$b8a4125304d344d;
    }
    /**
   * Creates a dataset for the app.
   *
   * @param datasetId - The dataset ID for the dataset to create.
   * @param params - Additional parameters to be passed to the Dataset.
   *
   * @returns A Dataset object for the specified dataset ID.
   *
   * @includeExample examples/app/createDataset.ts
   */ async createDataset({ datasetId: datasetId, params: params = {} }) {
        const request = new (0, $hgUW1$PostDatasetsRequest)();
        request.setUserAppId(this.userAppId);
        const newDataSet = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$Dataset), params);
        newDataSet.setId(datasetId);
        request.setDatasetsList([
            newDataSet
        ]);
        const postDatasets = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postDatasets, this.STUB.client);
        const response = await this.grpcRequest(postDatasets, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nDataset created\n%s", responseObject.status.description);
        return responseObject.datasetsList?.[0];
    }
    /**
   * Creates a model for the app.
   *
   * @param modelId - The model ID for the model to create.
   * @param params - Additional parameters to be passed to the Model.
   *
   * @returns A Model object for the specified model ID.
   *
   * @includeExample examples/app/createModel.ts
   */ async createModel({ modelId: modelId, params: params = {} }) {
        const request = new (0, $hgUW1$PostModelsRequest)();
        request.setUserAppId(this.userAppId);
        const newModel = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$Model), {
            id: modelId,
            ...params
        });
        request.setModelsList([
            newModel
        ]);
        const postModels = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postModels, this.STUB.client);
        const response = await this.grpcRequest(postModels, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS || !responseObject.model) throw new Error(responseObject.status?.description);
        console.info("\nModel created\n%s", responseObject.status.description);
        return responseObject.model;
    }
    /**
   * Creates a module for the app.
   *
   * @param moduleId - The module ID for the module to create.
   * @param description - The description of the module to create.
   * @returns A Module object for the specified module ID.
   *
   * @includeExample examples/app/createModule.ts
   */ async createModule({ moduleId: moduleId, description: description }) {
        const request = new (0, $hgUW1$PostModulesRequest)();
        request.setUserAppId(this.userAppId);
        const newModule = new (0, $hgUW1$Module)();
        newModule.setId(moduleId);
        newModule.setDescription(description);
        request.setModulesList([
            newModule
        ]);
        const postModules = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postModules, this.STUB.client);
        const response = await this.grpcRequest(postModules, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nModule created\n%s", responseObject.status.description);
        return responseObject.modulesList?.[0];
    }
    /**
   * Creates a workflow for the app.
   *
   * @param configFilePath - The path to the yaml workflow config file.
   * @param generateNewId - If true, generate a new workflow ID.
   * @param display - If true, display the workflow nodes tree.
   * @returns A Workflow object for the specified workflow config.
   *
   * @includeExample examples/app/createWorkflow.ts
   */ async createWorkflow({ configFilePath: configFilePath, generateNewId: generateNewId = false, display: display = true }) {
        if (!$hgUW1$existsSync(configFilePath)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Workflow config file not found at ${configFilePath}`);
        const data = $hgUW1$load($hgUW1$readFileSync(configFilePath, "utf8"));
        const validatedData = (0, $f58a83054e170fa6$export$8e5c4bbe6bcfd175)(data);
        const workflow = validatedData["workflow"];
        // Get all model objects from the workflow nodes.
        const allModels = [];
        for (const node of workflow.nodes){
            let modelObject;
            const outputInfo = (0, $a3ecf8aee6db342a$export$b4483c4bf292a57b)(node?.model?.outputInfo ?? {});
            try {
                const model = await this.model({
                    modelId: node.model.modelId,
                    modelVersionId: node.model.modelVersionId ?? "",
                    modelUserAppId: node.model.userId && node.model.appId ? {
                        userId: node.model.userId,
                        appId: node.model.appId
                    } : undefined
                });
                modelObject = model;
                if (model) allModels.push(model);
            } catch (e) {
                // model doesn't exist, create a new model from yaml config
                if (e?.message?.includes("Model does not exist")) {
                    const { modelId: modelId, ...otherParams } = node.model;
                    modelObject = await this.createModel({
                        modelId: modelId,
                        params: otherParams
                    });
                    const model = new (0, $2e0e50b57c59b46b$export$a1edc412be3e1841)({
                        modelId: modelObject.id,
                        authConfig: {
                            pat: this.pat,
                            appId: this.userAppId.getAppId(),
                            userId: this.userAppId.getUserId()
                        }
                    });
                    if (outputInfo) {
                        const modelVersion = new (0, $hgUW1$ModelVersion)().setOutputInfo(outputInfo);
                        const modelWithVersion = await model.createVersion(modelVersion);
                        if (modelWithVersion) {
                            allModels.push(modelWithVersion);
                            continue;
                        }
                    } else {
                        await model.loadInfo();
                        allModels.push(model.modelInfo.toObject());
                    }
                }
            }
        }
        // Convert nodes to resources_pb2.WorkflowNodes.
        const nodes = [];
        for(let i = 0; i < workflow["nodes"].length; i++){
            const ymlNode = workflow["nodes"][i];
            const node = {
                id: ymlNode["id"],
                model: allModels[i],
                // TODO: setting default values, need to check for right values to set here
                nodeInputsList: [],
                // TODO: setting default values, need to check for right values to set here
                suppressOutput: false
            };
            // Add node inputs if they exist, i.e. if these nodes do not connect directly to the input.
            if (ymlNode.nodeInputs) for (const ni of ymlNode.nodeInputs)node?.nodeInputsList.push({
                nodeId: ni.nodeId
            });
            nodes.push(node);
        }
        let workflowId = workflow["id"];
        if (generateNewId) workflowId = (0, $hgUW1$v4)();
        // Create the workflow.
        const request = new (0, $hgUW1$PostWorkflowsRequest)();
        request.setUserAppId(this.userAppId);
        const workflowNodesList = nodes.map((eachNode)=>(0, $hgUW1$fromProtobufObject)((0, $hgUW1$WorkflowNode), eachNode));
        request.setWorkflowsList([
            new (0, $hgUW1$Workflow)().setId(workflowId).setNodesList(workflowNodesList)
        ]);
        const postWorkflows = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postWorkflows, this.STUB.client);
        const response = await this.grpcRequest(postWorkflows, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nWorkflow created\n%s", responseObject.status?.description);
        // Display the workflow nodes tree.
        if (display) console.table((0, $hgUW1$flatten)(responseObject.workflowsList?.[0]?.nodesList));
        return responseObject.workflowsList?.[0];
    }
    /**
   * Returns a Model object for the existing model ID.
   *
   * @param modelId - The model ID for the existing model.
   * @param modelVersionId - Specific version id of the model.
   * @param modelUserAppId - The user app ID for the model.
   * @returns A model object for the specified model ID.
   *
   * @includeExample examples/app/model.ts
   */ async model({ modelId: modelId, modelVersionId: modelVersionId, modelUserAppId: modelUserAppId }) {
        const request = new (0, $hgUW1$GetModelRequest)();
        if (modelUserAppId) request.setUserAppId(new (0, $hgUW1$UserAppIDSet)().setAppId(modelUserAppId.appId).setUserId(modelUserAppId.userId));
        else request.setUserAppId(this.userAppId);
        request.setModelId(modelId);
        if (modelVersionId) request.setVersionId(modelVersionId);
        const getModel = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getModel, this.STUB.client);
        const response = await this.grpcRequest(getModel, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        return responseObject.model;
    }
    /**
   * Returns a Workflow object for the existing workflow ID.
   *
   * @param workflowId - The workflow ID for a existing workflow.
   * @returns A workflow object for the specified workflow ID.
   *
   * @includeExample examples/app/workflow.ts
   */ async workflow({ workflowId: workflowId }) {
        const request = new (0, $hgUW1$GetWorkflowRequest)();
        request.setUserAppId(this.userAppId);
        request.setWorkflowId(workflowId);
        const getWorkflow = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getWorkflow, this.STUB.client);
        const response = await this.grpcRequest(getWorkflow, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        return responseObject.workflow;
    }
    /**
   * Returns a Dataset object for the existing dataset ID.
   *
   * @param dataset_id - The dataset ID for the dataset to interact with.
   * @returns A Dataset object for the existing dataset ID.
   *
   * @includeExample examples/app/dataset.ts
   */ async dataset({ datasetId: datasetId }) {
        const request = new (0, $hgUW1$GetDatasetRequest)();
        request.setUserAppId(this.userAppId);
        request.setDatasetId(datasetId);
        const getDataset = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getDataset, this.STUB.client);
        const response = await this.grpcRequest(getDataset, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        return responseObject.dataset;
    }
    /**
   * Deletes a dataset for the user.
   *
   * @param datasetId - The dataset ID for the app to delete.
   *
   * @includeExample examples/app/deleteDataset.ts
   */ async deleteDataset({ datasetId: datasetId }) {
        const request = new (0, $hgUW1$DeleteDatasetsRequest)();
        request.setUserAppId(this.userAppId);
        request.setDatasetIdsList([
            datasetId
        ]);
        const deleteDatasets = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteDatasets, this.STUB.client);
        const response = await this.grpcRequest(deleteDatasets, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nDataset Deleted\n%s", responseObject.status?.description);
    }
    /**
   * Deletes a model for the user.
   *
   * @param modelId - The model ID for the model to delete.
   *
   * @includeExample examples/app/deleteModel.ts
   */ async deleteModel({ modelId: modelId }) {
        const request = new (0, $hgUW1$DeleteModelsRequest)();
        request.setUserAppId(this.userAppId);
        request.setIdsList([
            modelId
        ]);
        const deleteModels = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteModels, this.STUB.client);
        const response = await this.grpcRequest(deleteModels, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nModel Deleted\n%s", responseObject.status?.description);
    }
    /**
   * Deletes a workflow for the user.
   *
   * @param workflowId - The workflow ID for the workflow to delete.
   *
   * @includeExample examples/app/deleteWorkflow.ts
   */ async deleteWorkflow({ workflowId: workflowId }) {
        const request = new (0, $hgUW1$DeleteWorkflowsRequest)();
        request.setUserAppId(this.userAppId);
        request.setIdsList([
            workflowId
        ]);
        const deleteWorkflows = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteWorkflows, this.STUB.client);
        const response = await this.grpcRequest(deleteWorkflows, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nWorkflow Deleted\n%s", responseObject.status?.description);
    }
    /**
   * Deletes a module for the user.
   *
   * @param moduleId - The module ID for the module to delete.
   *
   * @includeExample examples/app/deleteModule.ts
   */ async deleteModule({ moduleId: moduleId }) {
        const request = new (0, $hgUW1$DeleteModulesRequest)();
        request.setUserAppId(this.userAppId);
        request.setIdsList([
            moduleId
        ]);
        const deleteModules = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteModules, this.STUB.client);
        const response = await this.grpcRequest(deleteModules, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nModule Deleted\n%s", responseObject.status?.description);
    }
}




var $50e6496e5fb64e47$exports = {};

$parcel$export($50e6496e5fb64e47$exports, "Search", () => $50e6496e5fb64e47$export$4b85d3515bd863a5);
const $0e12ca7fc0a3ddfa$export$e4f0656f1a71194a = 10;
const $0e12ca7fc0a3ddfa$export$4455b7a6b71908b2 = "euclidean";
const $0e12ca7fc0a3ddfa$export$4dcdbb431212ada = "nearest_neighbor";







function $fc32275c5d3b15c2$export$19a621270f26273c() {
    // Schema for a single concept
    const conceptSchema = (0, $hgUW1$z).object({
        value: (0, $hgUW1$z).number().min(0).max(1).optional(),
        id: (0, $hgUW1$z).string().min(1).optional(),
        language: (0, $hgUW1$z).string().min(1).optional(),
        name: (0, $hgUW1$z).string().min(1).regex(/^[0-9A-Za-z]+([-_][0-9A-Za-z]+)*$/) // Non-empty string with dashes/underscores
        .optional()
    }).strict();
    // Schema for a rank or filter item
    const rankFilterItemSchema = (0, $hgUW1$z).object({
        imageUrl: (0, $hgUW1$z).string().url().optional(),
        textRaw: (0, $hgUW1$z).string().min(1).optional(),
        metadata: (0, $hgUW1$z).record((0, $hgUW1$z).unknown()).optional(),
        imageBytes: (0, $hgUW1$z).unknown().optional(),
        geoPoint: (0, $hgUW1$z).object({
            longitude: (0, $hgUW1$z).number(),
            latitude: (0, $hgUW1$z).number(),
            geoLimit: (0, $hgUW1$z).number().int()
        }).strict().optional(),
        concepts: (0, $hgUW1$z).array(conceptSchema).min(1).optional(),
        // input filters
        inputTypes: (0, $hgUW1$z).array((0, $hgUW1$z).enum([
            "image",
            "video",
            "text",
            "audio"
        ])).optional(),
        inputDatasetIds: (0, $hgUW1$z).array((0, $hgUW1$z).string()).optional(),
        inputStatusCode: (0, $hgUW1$z).number().optional()
    }).strict();
    // Schema for rank and filter args
    return (0, $hgUW1$z).array(rankFilterItemSchema);
}








var $50e6496e5fb64e47$require$Buffer = $hgUW1$Buffer;
class $50e6496e5fb64e47$export$4b85d3515bd863a5 extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    constructor({ topK: topK = (0, $0e12ca7fc0a3ddfa$export$e4f0656f1a71194a), metric: metric = (0, $0e12ca7fc0a3ddfa$export$4455b7a6b71908b2), authConfig: authConfig, algorithm: algorithm = (0, $0e12ca7fc0a3ddfa$export$4dcdbb431212ada) }){
        super({
            pageSize: 1000,
            authConfig: authConfig
        });
        if (metric !== "cosine" && metric !== "euclidean") throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Metric should be either cosine or euclidean");
        if (algorithm !== "nearest_neighbor" && algorithm !== "brute_force") throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Algorithm should be either nearest_neighbor or brute_force");
        this.topK = topK;
        this.algorithm = algorithm;
        this.metricDistance = ({
            cosine: "COSINE_DISTANCE",
            euclidean: "EUCLIDEAN_DISTANCE"
        })[metric];
        this.dataProto = new (0, $hgUW1$Data)();
        this.inputProto = new (0, $hgUW1$Input)();
    }
    getAnnotProto(args) {
        if (Object.keys(args).length === 0) return new (0, $hgUW1$Annotation)();
        this.dataProto = new (0, $hgUW1$Data)();
        for (const [key, value] of Object.entries(args)){
            if (key === "imageBytes") {
                const imageProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
                    inputId: "",
                    imageBytes: value
                }).getData()?.getImage();
                this.dataProto.setImage(imageProto);
            } else if (key === "imageUrl") {
                const imageProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
                    inputId: "",
                    imageUrl: value
                }).getData()?.getImage();
                this.dataProto.setImage(imageProto);
            } else if (key === "concepts") {
                if (value) {
                    const conceptsList = [];
                    for (const concept of value){
                        const conceptProto = new (0, $hgUW1$Concept)();
                        if (concept.id) conceptProto.setId(concept.id);
                        if (concept.name) conceptProto.setName(concept.name);
                        if (concept.value) conceptProto.setValue(concept.value);
                        if (concept.language) conceptProto.setLanguage(concept.language);
                        conceptsList.push(conceptProto);
                    }
                    this.dataProto.setConceptsList(conceptsList);
                }
            } else if (key === "textRaw") {
                const textProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
                    inputId: "",
                    textBytes: $50e6496e5fb64e47$require$Buffer.from(value, "utf-8")
                }).getData()?.getText();
                this.dataProto.setText(textProto);
            } else if (key === "metadata") {
                const metadataStruct = (0, $hgUW1$Struct).fromJavaScript(value);
                this.dataProto.setMetadata(metadataStruct);
            } else if (key === "geoPoint") {
                if (value) {
                    const { longitude: longitude, latitude: latitude, geoLimit: geoLimit } = value;
                    const geoPointProto = this.getGeoPointProto(longitude, latitude, geoLimit);
                    this.dataProto.setGeo(geoPointProto);
                }
            } else throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`arguments contain key that is not supported: ${key}`);
        }
        const annotation = new (0, $hgUW1$Annotation)();
        annotation.setData(this.dataProto);
        return annotation;
    }
    getInputProto(args) {
        if (Object.keys(args).length === 0) return new (0, $hgUW1$Input)();
        this.inputProto = new (0, $hgUW1$Input)();
        this.dataProto = new (0, $hgUW1$Data)();
        for (const [key, value] of Object.entries(args)){
            if (key === "inputTypes") {
                for (const inputType of value ?? []){
                    if (inputType === "image") this.dataProto.setImage(new (0, $hgUW1$Image)());
                    else if (inputType === "text") this.dataProto.setText(new (0, $hgUW1$Text)());
                    else if (inputType === "audio") this.dataProto.setAudio(new (0, $hgUW1$Audio)());
                    else if (inputType === "video") this.dataProto.setVideo(new (0, $hgUW1$Video)());
                }
                this.inputProto.setData(this.dataProto);
            } else if (key === "inputDatasetIds") this.inputProto.setDatasetIdsList(value);
            else if (key === "inputStatusCode") {
                const statusCode = new (0, $hgUW1$Status)().setCode(value);
                this.inputProto.setStatus(statusCode);
            } else throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`args contain key that is not supported: ${key}`);
        }
        return this.inputProto;
    }
    getGeoPointProto(longitude, latitude, geoLimit) {
        const geo = new (0, $hgUW1$Geo)();
        const geoPoint = new (0, $hgUW1$GeoPoint)();
        geoPoint.setLongitude(longitude);
        geoPoint.setLatitude(latitude);
        const geoLimitConstructor = new (0, $hgUW1$GeoLimit)();
        geoLimitConstructor.setType("withinKilometers");
        geoLimitConstructor.setValue(geoLimit);
        geo.setGeoPoint(geoPoint);
        geo.setGeoLimit(geoLimitConstructor);
        return geo;
    }
    async *listAllPagesGenerator({ endpoint: endpoint, requestData: requestData, page: page = 1, perPage: perPage }) {
        const maxPages = Math.ceil(this.topK / this.defaultPageSize);
        let totalHits = 0;
        while(page){
            if (!perPage) {
                if (page === maxPages) perPage = this.topK - totalHits;
                else perPage = this.defaultPageSize;
            }
            const pagination = new (0, $hgUW1$Pagination)();
            pagination.setPage(page);
            pagination.setPerPage(perPage);
            requestData.setPagination(pagination);
            // @ts-expect-error - endpoint type is a generic & causes type error here
            const response = await this.grpcRequest(endpoint, requestData);
            const responseObject = response.toObject();
            if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) {
                if (responseObject.status?.details.includes("page * perPage cannot exceed")) {
                    const msg = `Your topK is set to ${this.topK}. The current pagination settings exceed the limit. Please reach out to support@clarifai.com to request an increase for your use case.\nreqId: ${responseObject.status?.reqId}`;
                    throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(msg);
                } else throw new Error(`Listing failed with response ${responseObject.status?.description}`);
            }
            if (!("hitsList" in responseObject) || responseObject.hitsList.length === 0) {
                yield responseObject;
                break;
            }
            page += 1;
            totalHits += perPage;
            yield responseObject;
        }
    }
    query({ ranks: ranks = [
        {}
    ], filters: filters = [
        {}
    ], page: page, perPage: perPage }) {
        try {
            (0, $fc32275c5d3b15c2$export$19a621270f26273c)().parse(ranks);
            (0, $fc32275c5d3b15c2$export$19a621270f26273c)().parse(filters);
        } catch (err) {
            throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Invalid rank or filter input: ${err}`);
        }
        const rankAnnotProto = [];
        for (const rankObject of ranks)rankAnnotProto.push(this.getAnnotProto(rankObject));
        const allRanks = rankAnnotProto.map((rankAnnot)=>{
            const rank = new (0, $hgUW1$Rank)();
            rank.setAnnotation(rankAnnot);
            return rank;
        });
        if (filters.length && Object.keys(filters[0]).some((k)=>k.includes("input"))) {
            const filtersInputProto = [];
            for (const filterDict of filters)filtersInputProto.push(this.getInputProto(filterDict));
            const allFilters = filtersInputProto.map((filterInput)=>{
                const filter = new (0, $hgUW1$Filter)();
                filter.setInput(filterInput);
                return filter;
            });
            const query = new (0, $hgUW1$Query)();
            query.setRanksList(allRanks);
            query.setFiltersList(allFilters);
            const search = new (0, $hgUW1$Search)();
            search.setQuery(query);
            search.setAlgorithm(this.algorithm);
            search.setMetric((0, $hgUW1$Search)["Metric"][this.metricDistance]);
            const postInputsSearches = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postInputsSearches, this.STUB.client);
            const request = new (0, $hgUW1$PostInputsSearchesRequest)();
            request.setUserAppId(this.userAppId);
            request.setSearchesList([
                search
            ]);
            return this.listAllPagesGenerator({
                endpoint: postInputsSearches,
                requestData: request,
                page: page,
                perPage: perPage
            });
        }
        const filtersAnnotProto = [];
        for (const filterDict of filters)filtersAnnotProto.push(this.getAnnotProto(filterDict));
        const allFilters = filtersAnnotProto.map((filterAnnot)=>{
            const filter = new (0, $hgUW1$Filter)();
            filter.setAnnotation(filterAnnot);
            return filter;
        });
        const query = new (0, $hgUW1$Query)();
        query.setRanksList(allRanks);
        query.setFiltersList(allFilters);
        const search = new (0, $hgUW1$Search)();
        search.setQuery(query);
        search.setAlgorithm(this.algorithm);
        search.setMetric((0, $hgUW1$Search)["Metric"][this.metricDistance]);
        const postAnnotationsSearches = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postAnnotationsSearches, this.STUB.client);
        const request = new (0, $hgUW1$PostAnnotationsSearchesRequest)();
        request.setUserAppId(this.userAppId);
        request.setSearchesList([
            search
        ]);
        return this.listAllPagesGenerator({
            endpoint: postAnnotationsSearches,
            requestData: request,
            page: page,
            perPage: perPage
        });
    }
}


var $8a79cc7cf138de65$exports = {};

$parcel$export($8a79cc7cf138de65$exports, "Workflow", () => $8a79cc7cf138de65$export$7123ae228ad720a);




const $f30a107fa8915fd6$export$7a02025250941104 = 32;








const $5777839c2a66bce9$var$VALID_YAML_KEYS = [
    "workflow",
    "id",
    "nodes",
    "nodesList",
    "nodeInputs",
    "nodeInputsList",
    "nodeId",
    "model"
];
class $5777839c2a66bce9$export$a46f15a9a9fee68a {
    constructor(workflow){
        this.wf = workflow;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    parse() {
        if (Array.isArray(this.wf)) this.wf = this.wf[0];
        const wf = {
            workflow: this.wf
        };
        const clean_wf = $5777839c2a66bce9$var$cleanUpUnusedKeys(wf);
        this.wf_dict = clean_wf;
        return clean_wf;
    }
    export(out_path) {
        const yamlString = $hgUW1$dump(this.wf_dict?.["workflow"], {
            flowLevel: -1,
            replacer: (_key, val)=>{
                if (Array.isArray(val) && val.length === 0) return undefined;
                return val;
            }
        });
        $hgUW1$writeFileSync(out_path, yamlString.replace(new RegExp("sList", "g"), "s"));
    }
    close() {
        delete this.wf;
        delete this.wf_dict;
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function $5777839c2a66bce9$var$cleanUpUnusedKeys(wf) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const new_wf = {};
    for (const [key, val] of Object.entries(wf)){
        if (!$5777839c2a66bce9$var$VALID_YAML_KEYS.includes(key)) continue;
        if (key === "model") {
            new_wf["model"] = {
                modelId: wf["model"]["id"],
                modelVersionId: wf["model"]["modelVersion"]["id"]
            };
            // If the model is not from clarifai main, add the app_id and user_id to the model dict.
            if (wf["model"]["userId"] !== "clarifai" && wf["model"]["appId"] !== "main") new_wf["model"] = {
                ...new_wf["model"],
                appId: wf["model"]["appId"],
                userId: wf["model"]["userId"]
            };
        } else if (Array.isArray(val)) {
            const new_list = val.map((i)=>$5777839c2a66bce9$var$cleanUpUnusedKeys(i));
            new_wf[key] = new_list;
        } else if (typeof val === "object") new_wf[key] = $5777839c2a66bce9$var$cleanUpUnusedKeys(val);
        else new_wf[key] = val;
    }
    return new_wf;
}




var $8a79cc7cf138de65$require$Buffer = $hgUW1$Buffer;
class $8a79cc7cf138de65$export$7123ae228ad720a extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    constructor({ url: url, workflowId: workflowId, workflowVersion: workflowVersion = {
        id: ""
    }, outputConfig: outputConfig = {
        minValue: 0
    }, authConfig: authConfig = {} }){
        if (url && workflowId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You can only specify one of url or workflow_id.");
        if (!url && !workflowId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You must specify one of url or workflow_id.");
        if (url) {
            const [userId, appId, , _workflowId, workflowVersionId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiUrl(url);
            if (workflowVersionId) workflowVersion.id = workflowVersionId;
            authConfig.userId = userId;
            authConfig.appId = appId;
            workflowId = _workflowId;
        }
        super({
            authConfig: authConfig
        });
        this.id = workflowId || "";
        this.versionId = workflowVersion.id;
        this.outputConfig = outputConfig;
        this.appId = authConfig.appId || undefined;
    }
    async predict({ inputs: inputs, workflowStateId: workflowStateId }) {
        if (inputs.length > (0, $f30a107fa8915fd6$export$7a02025250941104)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`Too many inputs. Max is ${(0, $f30a107fa8915fd6$export$7a02025250941104)}.`);
        const request = new (0, $hgUW1$PostWorkflowResultsRequest)();
        request.setUserAppId(this.userAppId);
        request.setWorkflowId(this.id);
        request.setVersionId(this.versionId);
        request.setInputsList(inputs);
        const outputConfig = (0, $2453de9811f0eca7$export$8db309f08fe1953c)((0, $hgUW1$OutputConfig), this.outputConfig);
        request.setOutputConfig(outputConfig);
        if (workflowStateId) {
            const workflowState = new (0, $hgUW1$WorkflowState)();
            workflowState.setId(workflowStateId);
            request.setWorkflowState(workflowState);
        }
        const startTime = Date.now();
        const backoffIterator = new (0, $199a96159c1768e2$export$8bd55c4683eb5fb0)();
        const postWorkflowResults = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postWorkflowResults, this.STUB.client);
        return new Promise((resolve, reject)=>{
            const makeRequest = ()=>{
                this.grpcRequest(postWorkflowResults, request).then((response)=>{
                    const responseObject = response.toObject();
                    if (responseObject.status?.code === (0, $hgUW1$StatusCode).MODEL_DEPLOYING && Date.now() - startTime < 600000) {
                        console.log(`${this.id} Workflow is still deploying, please wait...`);
                        setTimeout(makeRequest, backoffIterator.next().value * 1000);
                    } else if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) reject(new Error(`Workflow Predict failed with response ${responseObject.status?.description}`));
                    else resolve(response.toObject());
                }).catch((error)=>{
                    reject(new Error(`Model Predict failed with error: ${error.message}`));
                });
            };
            makeRequest();
        });
    }
    predictByBytes(inputBytes, inputType) {
        if (![
            "image",
            "text",
            "video",
            "audio"
        ].includes(inputType)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid input type. It should be image, text, video, or audio.");
        if (!$8a79cc7cf138de65$require$Buffer.isBuffer(inputBytes)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid bytes.");
        let inputProto = new (0, $hgUW1$Input)();
        if (inputType === "image") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            imageBytes: inputBytes
        });
        else if (inputType === "text") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            textBytes: inputBytes
        });
        else if (inputType === "video") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            videoBytes: inputBytes
        });
        else if (inputType === "audio") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromBytes({
            inputId: "",
            audioBytes: inputBytes
        });
        return this.predict({
            inputs: [
                inputProto
            ]
        });
    }
    predictByUrl(url, inputType) {
        if (![
            "image",
            "text",
            "video",
            "audio"
        ].includes(inputType)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid input type. It should be image, text, video, or audio.");
        let inputProto = new (0, $hgUW1$Input)();
        if (inputType === "image") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            imageUrl: url
        });
        else if (inputType === "text") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            textUrl: url
        });
        else if (inputType === "video") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            videoUrl: url
        });
        else if (inputType === "audio") inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputFromUrl({
            inputId: "",
            audioUrl: url
        });
        return this.predict({
            inputs: [
                inputProto
            ]
        });
    }
    async *listVersions({ pageNo: pageNo, perPage: perPage }) {
        const request = new (0, $hgUW1$ListWorkflowVersionsRequest)();
        request.setUserAppId(this.userAppId);
        request.setWorkflowId(this.id);
        const listWorkflowVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listWorkflowVersions, this.STUB.client);
        const workflowVersionsGenerator = this.listPagesGenerator(listWorkflowVersions, request, perPage, pageNo);
        for await (const workflowVersionInfo of workflowVersionsGenerator){
            const workflowVersion = workflowVersionInfo.toObject();
            yield workflowVersion;
        }
    }
    /**
   * Exports the workflow to a yaml file.
   *
   * @param outPath - The path to save the yaml file to.
   *
   * @example
   * ```typescript
   * import { Workflow } from "./workflow";
   *
   * const workflow = new Workflow("https://clarifai.com/clarifai/main/workflows/Demographics");
   * await workflow.export("out_path.yml");
   * ```
   */ async exportWorkflow(outPath) {
        const request = new (0, $hgUW1$GetWorkflowRequest)();
        request.setUserAppId(this.userAppId);
        request.setWorkflowId(this.id);
        const getWorkflow = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.getWorkflow, this.STUB.client);
        const response = await this.grpcRequest(getWorkflow, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(`Workflow Export failed with response ${response.getStatus()?.toString()}`);
        const exporter = new (0, $5777839c2a66bce9$export$a46f15a9a9fee68a)(responseObject);
        exporter.parse();
        exporter.export(outPath);
    }
}


var $1fe20b5401698010$exports = {};

$parcel$export($1fe20b5401698010$exports, "Dataset", () => $1fe20b5401698010$export$827063163a0a89f5);









class $1fe20b5401698010$export$827063163a0a89f5 extends (0, $f7e2ee1c151bc7f7$export$be1f67df1c66692d) {
    constructor({ authConfig: authConfig, datasetId: datasetId, url: url, datasetVersionId: datasetVersionId }){
        if (url && datasetId) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("You can only specify one of url or dataset_id.");
        if (url) {
            const [userId, appId, , _datasetId, _datasetVersionId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiUrl(url);
            if (authConfig) authConfig.userId = userId;
            if (authConfig) authConfig.appId = appId;
            datasetId = _datasetId;
            datasetVersionId = _datasetVersionId;
        }
        super({
            authConfig: authConfig
        });
        this.info = new (0, $hgUW1$Dataset)();
        this.batchSize = 128;
        this.info.setId(datasetId);
        this.info.setVersion(new (0, $hgUW1$DatasetVersion)().setId(datasetVersionId));
        this.input = new (0, $837b266c4810d7cb$export$f5b8910cec6cf069)({
            authConfig: authConfig
        });
    }
    async createVersion({ id: id, description: description, metadata: metadata = {} }) {
        const request = new (0, $hgUW1$PostDatasetVersionsRequest)();
        request.setUserAppId(this.userAppId);
        request.setDatasetId(this.info.getId());
        const datasetVersion = new (0, $hgUW1$DatasetVersion)();
        datasetVersion.setId(id);
        datasetVersion.setDescription(description);
        datasetVersion.setMetadata((0, $hgUW1$Struct).fromJavaScript(metadata));
        request.setDatasetVersionsList([
            datasetVersion
        ]);
        const postDatasetVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.postDatasetVersions, this.STUB.client);
        const response = await this.grpcRequest(postDatasetVersions, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nDataset Version created\n%s", response.getStatus());
        return responseObject.datasetVersionsList[0];
    }
    async deleteVersion(versionId) {
        const request = new (0, $hgUW1$DeleteDatasetVersionsRequest)();
        request.setUserAppId(this.userAppId);
        request.setDatasetId(this.info.getId());
        request.setDatasetVersionIdsList([
            versionId
        ]);
        const deleteDatasetVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.deleteDatasetVersions, this.STUB.client);
        const response = await this.grpcRequest(deleteDatasetVersions, request);
        const responseObject = response.toObject();
        if (responseObject.status?.code !== (0, $hgUW1$StatusCode).SUCCESS) throw new Error(responseObject.status?.description);
        console.info("\nDataset Version Deleted\n%s", response.getStatus());
    }
    async *listVersions(pageNo, perPage) {
        const request = new (0, $hgUW1$ListDatasetVersionsRequest)();
        request.setUserAppId(this.userAppId);
        request.setDatasetId(this.info.getId());
        const listDatasetVersions = (0, $199a96159c1768e2$export$54865a3d4693b845)(this.STUB.client.listDatasetVersions, this.STUB.client);
        const listDatasetVersionsGenerator = this.listPagesGenerator(listDatasetVersions, request, pageNo, perPage);
        for await (const versions of listDatasetVersionsGenerator)yield versions.toObject().datasetVersionsList;
    }
    async uploadFromFolder({ folderPath: folderPath, inputType: inputType, labels: labels = false, batchSize: batchSize = this.batchSize, uploadProgressEmitter: uploadProgressEmitter }) {
        if ([
            "image",
            "text"
        ].indexOf(inputType) === -1) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid input type");
        let inputProtos = [];
        if (inputType === "image") inputProtos = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getImageInputsFromFolder({
            folderPath: folderPath,
            datasetId: this.info.getId(),
            labels: labels
        });
        if (inputType === "text") inputProtos = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getTextInputsFromFolder({
            folderPath: folderPath,
            datasetId: this.info.getId(),
            labels: labels
        });
        await this.input.bulkUpload({
            inputs: inputProtos,
            batchSize: batchSize,
            uploadProgressEmitter: uploadProgressEmitter
        });
    }
    async uploadFromCSV({ csvPath: csvPath, inputType: inputType = "text", csvType: csvType, labels: labels = true, batchSize: batchSize = 128, uploadProgressEmitter: uploadProgressEmitter }) {
        if (![
            "image",
            "text",
            "video",
            "audio"
        ].includes(inputType)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid input type, it should be image, text, audio, or video");
        if (![
            "raw",
            "url",
            "file"
        ].includes(csvType)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Invalid csv type, it should be raw, url, or file_path");
        if (!csvPath.endsWith(".csv")) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("csvPath should be a csv file");
        if (csvType === "raw" && inputType !== "text") throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Only text input type is supported for raw csv type");
        batchSize = Math.min(128, batchSize);
        const inputProtos = await (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getInputsFromCsv({
            csvPath: csvPath,
            inputType: inputType,
            csvType: csvType,
            datasetId: this.info.getId(),
            labels: labels
        });
        await this.input.bulkUpload({
            inputs: inputProtos,
            batchSize: batchSize,
            uploadProgressEmitter: uploadProgressEmitter
        });
    }
}


var $094f001d8689dda0$exports = {};

$parcel$export($094f001d8689dda0$exports, "RAG", () => $094f001d8689dda0$export$27f215355c67f80c);








const $b7de494ec19259d2$export$23f295f9427f7362 = 128;









// Function to download a file and store it in a temporary file, and return MIME type
async function $c3236d185bc4465c$var$downloadFileToTemp(url) {
    try {
        // Create a temporary file
        const tempFile = (0, $hgUW1$tmp).fileSync({
            postfix: ".tmp"
        });
        console.log(`Temporary file created at: ${tempFile.name}`);
        // Fetch the file using axios
        const response = await (0, $hgUW1$axios)({
            method: "get",
            url: url,
            responseType: "stream"
        });
        const mimeType = response?.headers?.["Content-Type"]?.toString()?.toLowerCase();
        // Stream the file content to the temporary file
        response.data.pipe($hgUW1$createWriteStream(tempFile.name));
        return new Promise((resolve, reject)=>{
            response.data.on("end", ()=>{
                resolve({
                    filePath: tempFile.name,
                    mimeType: mimeType
                });
            });
            response.data.on("error", (err)=>{
                // Clean up the temporary file in case of an error
                tempFile.removeCallback();
                reject(err);
            });
        });
    } catch (error) {
        throw new Error(`Failed to download the file: ${error}`);
    }
}
function $c3236d185bc4465c$export$6bdadee9b169be35(messages) {
    let finalStr = "";
    for (const msg of messages)if ("role" in msg && "content" in msg) {
        const role = msg.role || "";
        const content = msg.content || "";
        finalStr += `\n\n${role}: ${content}`;
    }
    return finalStr;
}
function $c3236d185bc4465c$export$48f7b90332ae38cb(rawText) {
    return {
        role: "assistant",
        content: rawText
    };
}
async function $c3236d185bc4465c$export$7dec1cef721bc66b({ filePath: filePath, folderPath: folderPath, url: url }) {
    if (!filePath && !folderPath && !url) throw new Error("No input source provided.");
    // Load document from file
    if (filePath) {
        const fileExtension = filePath.slice(filePath.lastIndexOf("."));
        switch(fileExtension){
            case ".pdf":
                return await new (0, $hgUW1$PDFReader)().loadData(filePath);
            case ".docx":
                return await new (0, $hgUW1$DocxReader)().loadData(filePath);
            case ".txt":
                return await new (0, $hgUW1$TextFileReader)().loadData(filePath);
            default:
                throw new Error("Unsupported file type. Only .pdf, .docx, and .txt files are supported.");
        }
    }
    // Load all documents from a folder
    if (folderPath) {
        const reader = new (0, $hgUW1$SimpleDirectoryReader)();
        return await reader.loadData({
            directoryPath: folderPath,
            fileExtToReader: {
                pdf: new (0, $hgUW1$PDFReader)(),
                docx: new (0, $hgUW1$DocxReader)(),
                txt: new (0, $hgUW1$TextFileReader)()
            }
        });
    }
    // Load document from a URL
    if (url) {
        const downloadResponse = await $c3236d185bc4465c$var$downloadFileToTemp(url);
        let { mimeType: contentType } = downloadResponse;
        const { filePath: filePath } = downloadResponse;
        if (!contentType) contentType = url.split(".").pop()?.toLowerCase() ?? "";
        if (contentType === "txt" || /text\/plain/.test(contentType)) return await new (0, $hgUW1$TextFileReader)().loadData(filePath);
        else if (contentType === "docx" || /application\/vnd\.openxmlformats-officedocument\.wordprocessingml\.document/.test(contentType)) return await new (0, $hgUW1$DocxReader)().loadData(filePath);
        else if (contentType === "pdf" || /application\/pdf/.test(contentType)) return await new (0, $hgUW1$PDFReader)().loadData(filePath);
    }
    throw new Error("No documents loaded.");
}
function $c3236d185bc4465c$export$ec1bc409fca68863({ text: text, chunkSize: chunkSize, chunkOverlap: chunkOverlap, options: options = {} }) {
    const textParser = new (0, $hgUW1$SentenceSplitter)({
        ...options,
        chunkSize: chunkSize,
        chunkOverlap: chunkOverlap
    });
    const textChunks = textParser.splitText(text);
    return textChunks;
}




const $094f001d8689dda0$var$DEFAULT_RAG_PROMPT_TEMPLATE = "Context information is below:\n{data.hits}\nGiven the context information and not prior knowledge, answer the query.\nQuery: {data.text.raw}\nAnswer: ";
const $094f001d8689dda0$var$authConfigGuard = (authConfig)=>{
    if (authConfig?.appId && authConfig?.userId) return true;
    return false;
};
class $094f001d8689dda0$export$27f215355c67f80c {
    constructor({ workflowUrl: workflowUrl, workflow: workflow, authConfig: authConfig }){
        this.validateInputs(workflowUrl, workflow, authConfig);
        if (!authConfig || $094f001d8689dda0$var$authConfigGuard(authConfig)) {
            const targetAuthConfig = authConfig ?? {};
            this.authConfig = targetAuthConfig;
            this.promptWorkflow = workflow;
        } else {
            console.info("workflow_url:%s", workflowUrl);
            const [userId, appId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiUrl(workflowUrl);
            const w = new (0, $8a79cc7cf138de65$export$7123ae228ad720a)({
                url: workflowUrl,
                authConfig: authConfig
            });
            const targetAuthConfig = {
                ...authConfig,
                appId: appId,
                userId: userId
            };
            this.authConfig = targetAuthConfig;
            this.promptWorkflow = w;
        }
        this.app = new (0, $f0cf11edd3834060$export$86fbec116b87613f)({
            authConfig: this.authConfig
        });
    }
    validateInputs(workflowUrl, workflow, authConfig) {
        if (workflowUrl && workflow) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Only one of workflowUrl or workflow can be specified.");
        if (!workflowUrl && !workflow) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("One of workflowUrl or workflow must be specified.");
        if (workflowUrl && (authConfig?.userId || authConfig?.appId)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("userId and appId should not be specified in authConfig when using workflowUrl.");
    }
    static async setup({ authConfig: authConfig, appUrl: appUrl, llmUrl: llmUrl = "https://clarifai.com/mistralai/completion/models/mistral-7B-Instruct", baseWorkflow: baseWorkflow = "Text", workflowYamlFilename: workflowYamlFilename = "prompter_wf.yaml", promptTemplate: promptTemplate = $094f001d8689dda0$var$DEFAULT_RAG_PROMPT_TEMPLATE, workflowId: workflowId, minScore: minScore = 0.95, maxResults: maxResults = 5 }) {
        const { userId: userId, appId: appIdFromConfig } = authConfig ?? {};
        // Since user ID & App ID can be generated in different ways, we need to keep track of the generated ones
        let targetAppId = "", targetUserId = "";
        if (userId && appUrl) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Must provide one of userId or appUrl, not both.");
        if (appIdFromConfig && appUrl) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Must provide one of appId or appUrl, not both.");
        if (!userId && !appUrl) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("userId or appUrl must be provided. The userId can be found at https://clarifai.com/settings.");
        const [llmUserId, llmAppId, resourceType, llmId] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiUrl(llmUrl);
        if (resourceType !== "models") throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("llmUrl must be a model URL.");
        const nowTs = Date.now().toString();
        let app;
        if (userId && !appUrl) {
            const generatedAppId = `rag_app_${nowTs}`;
            // User ID is present, construct the authconfig using the generated APP ID
            const userAuthConfig = {
                ...authConfig,
                appId: generatedAppId
            };
            const user = new (0, $1eac708f26a71747$export$1f44aaf2ec115b54)(userAuthConfig);
            await user.createApp({
                appId: generatedAppId,
                baseWorkflow: baseWorkflow
            });
            app = new (0, $f0cf11edd3834060$export$86fbec116b87613f)({
                authConfig: userAuthConfig
            });
            targetAppId = generatedAppId;
            targetUserId = userId;
        }
        if (!userId && appUrl) {
            app = new (0, $f0cf11edd3834060$export$86fbec116b87613f)({
                url: appUrl,
                authConfig: authConfig
            });
            const [userIdFromAppUrl, appIdFromAppUrl] = (0, $5c07194696316c57$export$4fa98284752ac8ab).splitClarifaiAppUrl(appUrl);
            targetAppId = appIdFromAppUrl;
            targetUserId = userIdFromAppUrl;
        }
        let targetAuthConfig;
        if (authConfig) targetAuthConfig = {
            ...authConfig,
            appId: targetAppId,
            userId: targetUserId
        };
        else targetAuthConfig = {
            appId: targetAppId,
            userId: targetUserId,
            pat: undefined
        };
        const params = (0, $hgUW1$Struct).fromJavaScript({
            min_score: minScore,
            max_results: maxResults,
            prompt_template: promptTemplate
        });
        const outputInfo = new (0, $hgUW1$OutputInfo)().setParams(params);
        const modelId = workflowId ? `prompter-${workflowId}-${nowTs}` : `rag-prompter-${nowTs}`;
        // @ts-expect-error - app has been assigned but not picked up by typescript
        const prompterModelObj = await app.createModel({
            modelId: modelId,
            params: {
                modelTypeId: "rag-prompter"
            }
        });
        const prompterModel = new (0, $2e0e50b57c59b46b$export$a1edc412be3e1841)({
            authConfig: targetAuthConfig,
            modelId: prompterModelObj.id
        });
        const prompterModelWithVersion = await prompterModel.createVersion(new (0, $hgUW1$ModelVersion)().setOutputInfo(outputInfo));
        if (!prompterModelWithVersion?.id) throw new Error("Prompter model version creation failed.");
        workflowId = workflowId ? workflowId : `rag-wf-${nowTs}`;
        const workflowObject = {
            workflow: {
                id: workflowId,
                nodes: [
                    {
                        id: "rag-prompter",
                        model: {
                            modelId: prompterModelWithVersion.id,
                            modelVersionId: prompterModelWithVersion?.modelVersion?.id
                        }
                    },
                    {
                        id: "llm",
                        model: {
                            modelId: llmId,
                            userId: llmUserId,
                            appId: llmAppId
                        },
                        nodeInputs: [
                            {
                                nodeId: "rag-prompter"
                            }
                        ]
                    }
                ]
            }
        };
        const workflowYaml = (0, $hgUW1$jsyaml).dump(workflowObject, {
            noRefs: true
        });
        $hgUW1$writeFileSync(workflowYamlFilename, workflowYaml);
        // @ts-expect-error - app has been assigned but not picked up by typescript
        const wf = await app.createWorkflow({
            configFilePath: workflowYamlFilename
        });
        const workflow = new (0, $8a79cc7cf138de65$export$7123ae228ad720a)({
            workflowId: wf.id,
            authConfig: targetAuthConfig
        });
        return new $094f001d8689dda0$export$27f215355c67f80c({
            workflow: workflow,
            authConfig: targetAuthConfig
        });
    }
    async upload({ filePath: filePath, folderPath: folderPath, url: url, batchSize: batchSize = 128, chunkSize: chunkSize = 1024, chunkOverlap: chunkOverlap = 200, datasetId: datasetId, metadata: metadata }) {
        if (batchSize > (0, $b7de494ec19259d2$export$23f295f9427f7362)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)(`batch_size cannot be greater than ${(0, $b7de494ec19259d2$export$23f295f9427f7362)}`);
        if (filePath && (folderPath || url) || folderPath && (filePath || url) || url && (filePath || folderPath)) throw new (0, $28ac839a9eca26f5$export$3b14aa8c543ca7db)("Only one of file_path, folder_path, or url can be specified.");
        const documents = await (0, $c3236d185bc4465c$export$7dec1cef721bc66b)({
            filePath: filePath,
            folderPath: folderPath,
            url: url
        });
        const textChunks = [];
        const metadataList = [];
        let docI = 0;
        for (const doc of documents){
            const curTextChunks = (0, $hgUW1$lodashcompact)((0, $c3236d185bc4465c$export$ec1bc409fca68863)({
                text: doc.text,
                chunkSize: chunkSize,
                chunkOverlap: chunkOverlap
            }));
            textChunks.push(...curTextChunks);
            metadataList.push(...Array(curTextChunks.length).fill(doc.metadata));
            if (textChunks.length > batchSize) for(let idx = 0; idx < textChunks.length; idx += batchSize){
                if (idx + batchSize > textChunks.length) continue;
                const batchTexts = textChunks.slice(idx, idx + batchSize);
                const batchIds = Array(batchSize).fill(null).map(()=>(0, $hgUW1$v4)());
                const batchMetadatas = metadataList.slice(idx, idx + batchSize);
                const metaList = batchMetadatas.map((meta)=>{
                    const metaStruct = {
                        ...meta ? meta : {},
                        ...metadata && typeof metadata === "object" ? metadata : {},
                        docChunkNo: docI
                    };
                    docI += 1;
                    return metaStruct;
                });
                const inputBatch = batchTexts.map((text, i)=>{
                    return (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getTextInput({
                        inputId: batchIds[i],
                        rawText: text,
                        datasetId: datasetId,
                        metadata: metaList[i]
                    });
                });
                await new (0, $837b266c4810d7cb$export$f5b8910cec6cf069)({
                    authConfig: this.authConfig
                }).uploadInputs({
                    inputs: inputBatch
                });
                textChunks.splice(idx, batchSize);
                metadataList.splice(idx, batchSize);
            }
        }
        if (textChunks.length > 0) {
            const batchSize = textChunks.length;
            const batchIds = Array(batchSize).fill(null).map(()=>(0, $hgUW1$v4)());
            const batchMetadatas = metadataList.slice(0, batchSize);
            const metaList = batchMetadatas.map((meta)=>{
                const metaStruct = {
                    ...meta,
                    ...metadata && typeof metadata === "object" ? metadata : {},
                    docChunkNo: docI
                };
                docI += 1;
                return metaStruct;
            });
            const inputBatch = textChunks.map((text, i)=>{
                return (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getTextInput({
                    inputId: batchIds[i],
                    rawText: text,
                    datasetId: datasetId,
                    metadata: metaList[i]
                });
            });
            await new (0, $837b266c4810d7cb$export$f5b8910cec6cf069)({
                authConfig: this.authConfig
            }).uploadInputs({
                inputs: inputBatch
            });
            textChunks.splice(0, batchSize);
            metadataList.splice(0, batchSize);
        }
    }
    async chat({ messages: messages, clientManageState: clientManageState = true }) {
        if (!clientManageState) throw new Error("Server side state management is not supported yet - work in progress");
        const singlePrompt = (0, $c3236d185bc4465c$export$6bdadee9b169be35)(messages);
        const inputProto = (0, $837b266c4810d7cb$export$f5b8910cec6cf069).getTextInput({
            inputId: (0, $hgUW1$v4)(),
            rawText: singlePrompt
        });
        const response = await this.promptWorkflow.predict({
            inputs: [
                inputProto
            ]
        });
        const outputsList = response.resultsList?.[0]?.outputsList;
        const output = outputsList[outputsList.length - 1];
        messages.push((0, $c3236d185bc4465c$export$48f7b90332ae38cb)(output?.data?.text?.raw ?? ""));
        return messages;
    }
}




export {$1eac708f26a71747$export$1f44aaf2ec115b54 as User, $f0cf11edd3834060$export$86fbec116b87613f as App, $837b266c4810d7cb$export$f5b8910cec6cf069 as Input, $2e0e50b57c59b46b$export$a1edc412be3e1841 as Model, $50e6496e5fb64e47$export$4b85d3515bd863a5 as Search, $8a79cc7cf138de65$export$7123ae228ad720a as Workflow, $1fe20b5401698010$export$827063163a0a89f5 as Dataset, $094f001d8689dda0$export$27f215355c67f80c as RAG};
//# sourceMappingURL=module.js.map
