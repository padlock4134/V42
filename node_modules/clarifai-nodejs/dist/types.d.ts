import resources_pb2, { UserAppIDSet, App as _App1, Annotation, GeoPoint, Input as _Input1, Model as _Model1, ModelVersion, OutputConfig as _OutputConfig1, Workflow as _Workflow1, Module, InstalledModuleVersion, Concept, Dataset as _Dataset1, WorkflowState, DatasetVersion } from "clarifai-nodejs-grpc/proto/clarifai/api/resources_pb";
import { V2Client } from "clarifai-nodejs-grpc/proto/clarifai/api/service_grpc_pb";
import { grpc } from "clarifai-nodejs-grpc";
import * as jspb from "google-protobuf";
import { Status } from "clarifai-nodejs-grpc/proto/clarifai/api/status/status_pb";
import { Timestamp } from "google-protobuf/google/protobuf/timestamp_pb";
import { ListAppsRequest, ListRunnersRequest, MultiAppResponse, MultiRunnerResponse, SingleAppResponse, SingleRunnerResponse, MultiModelVersionResponse, MultiOutputResponse, ListDatasetsRequest, ListInstalledModuleVersionsRequest, ListModelsRequest, ListModulesRequest, ListWorkflowsRequest, MultiDatasetResponse, SingleModelResponse, SingleWorkflowResponse, SingleDatasetResponse, MultiSearchResponse, MultiWorkflowVersionResponse, PostWorkflowResultsResponse } from "clarifai-nodejs-grpc/proto/clarifai/api/service_pb";
import { JavaScriptValue } from "google-protobuf/google/protobuf/struct_pb";
import { EventEmitter } from "events";
import { z } from "zod";
type AuthConfig = {
    userId: string;
    appId: string;
    pat: string;
    rootCertificatesPath?: string;
    token?: string;
    base?: string;
    ui?: string;
} | Record<string, never>;
type PaginationRequestParams<T extends Record<string, unknown>> = Omit<Partial<T>, "userAppId" | "pageNo" | "perPage"> | Record<string, never>;
type Point = [number, number];
type Polygon = Point[];
declare const validResourceTypes: readonly ["modules", "models", "concepts", "inputs", "workflows", "tasks", "installed_module_versions"];
declare class ClarifaiAuthHelper {
    /**
     * A helper to get the authorization information needed to make API calls with the grpc
     * client to a specific app using a personal access token.
     *
     * There are class methods to make this object easily from either query_params provided by streamlit or from env vars.
     *
     * Note: only one of personal access token (pat) or a session token (token) can be provided.
     * Always use PATs in your code and never session tokens, those are only provided internal UI code.
     *
     * @param user_id - A user id who owns the resource you want to make calls to.
     * @param app_id - An app id for the application that owns the resource you want to interact with.
     * @param pat - A personal access token.
     * @param token - A session token (internal use only, always use a PAT).
     * @param base - A url to the API endpoint to hit. Examples include api.clarifai.com,
     *               https://api.clarifai.com (default), https://host:port, http://host:port,
     *               host:port (will be treated as http, not https). It's highly recommended to include
     *               the http:// or https:// otherwise we need to check the endpoint to determine if it has SSL during this __init__.
     * @param ui - A url to the UI. Examples include clarifai.com,
     *             https://clarifai.com (default), https://host:port, http://host:port,
     *             host:port (will be treated as http, not https). It's highly recommended to include
     *             the http:// or https:// otherwise we need to check the endpoint to determine if it has SSL during this __init__.
     * @param rootCertificatesPath - path to the root certificates file. This is only used for grpc secure channels.
     * @param validate - Whether to validate the inputs. This is useful for overriding vars then validating.
     */
    constructor(userId: string, appId: string, pat: string, token?: string, base?: string, ui?: string, rootCertificatesPath?: string, validate?: boolean);
    /**
     * Will look for the following env vars:
     * user_id: CLARIFAI_USER_ID env var.
     * app_id: CLARIFAI_APP_ID env var.
     * one of:
     *   token: CLARIFAI_SESSION_TOKEN env var.
     *   pat: CLARIFAI_PAT env var.
     * base: CLARIFAI_API_BASE env var.
     *
     * @param validate - Whether to validate the inputs. This is useful for overriding vars then validating.
     */
    static fromEnv(validate?: boolean): ClarifaiAuthHelper;
    /**
     * Get the gRPC metadata that contains either the session token or the PAT to use.
     *
     * @param userId - Optional user ID to override the default.
     * @param appId - Optional app ID to override the default.
     * @returns The metadata needed to send with all gRPC API calls in the API client.
     */
    getUserAppIdProto(userId?: string, appId?: string): resources_pb2.UserAppIDSet;
    /**
     * Get the gRPC metadata that contains either the session token or the PAT to use.
     *
     * @returns The metadata needed to send with all gRPC API calls in the API client.
     */
    get metadata(): [string, string][];
    /**
     * Get the API gRPC stub using the right channel based on the API endpoint base.
     * TODO: This method is currently not implemented due to the lack of a gRPC V2Stub in clarifai-node.js.
     *
     * @returns V2Client - The gRPC client to use to make API calls.
     */
    getStub(): V2Client;
    /**
     * Return the domain for the UI.
     */
    get ui(): string;
    /**
     * set the base domain for the API.
     * @param base - The base domain to set.
     */
    setBase(base: string): void;
    /**
     * set the domain for the UI.
     * @param ui - The UI domain to set.
     */
    setUi(ui: string): void;
    /**
     * Return the root certificates path.
     */
    get rootCertificatesPath(): string;
    /**
     * Return the base domain for the API.
     */
    get base(): string;
    /**
     * Return the personal access token.
     */
    get pat(): string;
    /**
     * Returns a string representation of the class.
     */
    toString(): string;
    /**
     * Return the list of the required environment variables.
     */
    static requiredEnvVars(): string[];
    /**
     * Validate the secrets.toml file has been filled with non-empty values for all the auth parameters that are present.
     *
     * @param tomlDict - The dictionary obtained from the secrets.toml file.
     */
    static validateSecretsDict(tomlDict: Record<string, unknown>): boolean;
    clarifaiUrl({ resourceType, resourceId, versionId, }: {
        resourceType: (typeof validResourceTypes)[number];
        resourceId: string;
        versionId?: string;
    }): string;
}
type V2Stub = AuthorizedStub | RetryStub;
type FirstParameterType<T> = T extends (arg1: infer P, ...args: unknown[]) => unknown ? P : never;
type CallbackParameterType<T> = T extends (arg1: unknown, callback: infer P, ...args: unknown[]) => unknown ? P : never;
type CallbackResponseType<T> = T extends (error: grpc.ServiceError | null, response: infer R) => void ? R : never;
declare class AuthorizedStub {
    client: V2Client;
    constructor(authHelper?: ClarifaiAuthHelper);
    makeCall<MethodName extends keyof V2Client>(methodName: MethodName, request: FirstParameterType<V2Client[MethodName]>): Promise<CallbackResponseType<CallbackParameterType<V2Client[MethodName]>>>;
    makeCallPromise<TRequest extends jspb.Message, TResponseObject extends {
        status?: Status.AsObject;
    }, TResponse extends {
        toObject: (arg?: boolean) => TResponseObject;
    }>(endpoint: (request: TRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>) => Promise<TResponse>, requestData: TRequest): Promise<TResponse>;
}
declare class RetryStub extends AuthorizedStub {
    constructor(authHelper?: ClarifaiAuthHelper, maxAttempts?: number, backoffTime?: number);
    makeCall<MethodName extends keyof V2Client>(methodName: MethodName, request: FirstParameterType<V2Client[MethodName]>): Promise<CallbackResponseType<CallbackParameterType<V2Client[MethodName]>>>;
    makeCallPromise<TRequest extends jspb.Message, TResponseObject extends {
        status?: Status.AsObject;
    }, TResponse extends {
        toObject: (arg?: boolean) => TResponseObject;
    }>(endpoint: (request: TRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>) => Promise<TResponse>, requestData: TRequest): Promise<TResponse>;
}
/**
 * BaseClient is the base class for all the classes interacting with Clarifai endpoints.
 * It initializes with various configuration options to set up the authentication helper,
 * gRPC stub, and other necessary properties for interacting with the Clarifai API.
 *
 * @property {ClarifaiAuthHelper} authHelper An instance of ClarifaiAuthHelper for authentication.
 * @property {V2Stub} STUB The gRPC Stub object for API interaction.
 * @property {[string, string][]} metadata The gRPC metadata containing the personal access token.
 * @property {string} pat The personal access token.
 * @property {UserAppIDSet} userAppId The protobuf object representing user and app IDs.
 * @property {string} base The base URL for the API endpoint.
 */
declare class BaseClient {
    protected authHelper: ClarifaiAuthHelper;
    protected STUB: V2Stub;
    protected metadata: [string, string][];
    protected pat: string;
    protected userAppId: UserAppIDSet;
    protected base: string;
    protected rootCertificatesPath: string;
    /**
     * Constructs a new BaseClient instance with specified configuration options.
     *
     * @param {Object} authConfig Configuration options for the client.
     * @param {string} authConfig.userId A user ID for authentication.
     * @param {string} authConfig.appId An app ID for the application to interact with.
     * @param {string} authConfig.pat A personal access token for authentication. If not provided, it attempts to fetch from environment variables.
     * @param {string} [authConfig.token] An optional token for authentication.
     * @param {string} [authConfig.base='https://api.clarifai.com'] The base URL for the API endpoint. Defaults to 'https://api.clarifai.com'.
     * @param {string} [authConfig.ui='https://clarifai.com'] The URL for the UI. Defaults to 'https://clarifai.com'.
     * @param {string} [authConfig.rootCertificatesPath] Path to the SSL root certificates file, used to establish secure gRPC connections.
     */
    constructor(authConfig?: AuthConfig);
    /**
     * Makes a gRPC request to the API.
     *
     * @param method The gRPC method to call.
     * @param argument The argument to pass to the gRPC method.
     * @returns A Promise resolving to the result of the gRPC method call.
     */
    protected grpcRequest<TRequest extends jspb.Message, TResponseObject extends {
        status?: Status.AsObject;
    }, TResponse extends {
        toObject: (arg?: boolean) => TResponseObject;
    }>(endpoint: (request: TRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>) => Promise<TResponse>, requestData: TRequest): Promise<TResponse>;
    /**
     * Converts a string to a Timestamp object.
     *
     * @param dateStr The string to convert.
     * @returns A Timestamp object representing the given date string.
     */
    convertStringToTimestamp(dateStr: string): Timestamp;
}
declare class Lister extends BaseClient {
    defaultPageSize: number;
    constructor({ authConfig, pageSize, }: {
        authConfig?: AuthConfig;
        pageSize?: number;
    });
    listPagesGenerator<TRequest extends jspb.Message, TResponseObject extends {
        status?: Status.AsObject;
    }, TResponse extends {
        toObject: (arg?: boolean) => TResponseObject;
    }>(endpoint: (request: TRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>) => Promise<TResponse>, requestData: TRequest, pageNo?: number, perPage?: number): AsyncGenerator<TResponse, void, unknown>;
    listPagesData<TRequest extends jspb.Message, TResponseObject extends {
        status?: Status.AsObject;
    }, TResponse extends {
        toObject: (arg?: boolean) => TResponseObject;
    }>(endpoint: (request: TRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>) => Promise<TResponse>, requestData: TRequest, pageNo?: number, perPage?: number): Promise<TResponse>;
}
export type UserConfig = AuthConfig;
export type ListAppsRequestParams = PaginationRequestParams<ListAppsRequest.AsObject>;
export type ListRunnersRequestParams = PaginationRequestParams<ListRunnersRequest.AsObject>;
/**
 * User is a class that provides access to Clarifai API endpoints related to user information.
 * @noInheritDoc
 */
export class User extends Lister {
    /**
     * Initializes an User object with the specified authentication configuration.
     *
     * @param authConfig An object containing the authentication configuration. Defaults to an empty object.
     * @param authConfig.userId The user ID for the user to interact with.
     * @param authConfig.appId The application ID associated with the user.
     * @param authConfig.pat A personal access token for authentication. Can also be set as an environment variable CLARIFAI_PAT.
     * @param authConfig.token A session token for authentication. Accepts either a session token or a personal access token (pat). Can also be set as an environment variable CLARIFAI_SESSION_TOKEN.
     * @param authConfig.base Optional. The base API URL. Defaults to "https://api.clarifai.com".
     * @param authConfig.ui Optional. Additional UI configurations.
     *
     * @includeExample examples/user/index.ts
     */
    constructor(authConfig?: UserConfig);
    /**
     * Lists all the apps for the user.
     *
     * @param params A dictionary of filters to be applied to the list of apps.
     * @param pageNo The page number to list.
     * @param perPage The number of items per page.
     * @yields App objects for the user.
     *
     * @includeExample examples/user/listApps.ts
     *
     * @note Defaults to 16 per page if pageNo is specified and perPage is not specified.
     * If both pageNo and perPage are None, then lists all the resources.
     */
    listApps({ params, pageNo, perPage, }?: {
        params?: ListAppsRequestParams;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<MultiAppResponse.AsObject["appsList"], void, unknown>;
    /**
     * Lists all the runners for the user.
     *
     * @param params A dictionary of filters to be applied to the list of runners.
     * @param pageNo The page number to list.
     * @param perPage The number of items per page.
     * @yields Runner objects for the user.
     *
     * @includeExample examples/user/listRunners.ts
     *
     * @note Defaults to 16 per page if perPage is not specified.
     */
    listRunners({ params, pageNo, perPage, }?: {
        params?: ListRunnersRequestParams;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<MultiRunnerResponse.AsObject, void, unknown>;
    /**
     * Creates an app for the user.
     *
     * @param appId The app ID for the app to create.
     * @param baseWorkflow The base workflow to use for the app. Examples: 'Universal', 'Language-Understanding', 'General'
     * @returns An App object for the specified app ID.
     *
     * @includeExample examples/user/createApp.ts
     */
    createApp({ appId, baseWorkflow, }: {
        appId: string;
        baseWorkflow?: string;
    }): Promise<_App1.AsObject>;
    /**
     * Creates a runner for the user.
     *
     * @param runnerId The Id of runner to create.
     * @param labels Labels to match runner.
     * @param description Description of Runner.
     * @returns A runner object for the specified Runner ID.
     *
     * @includeExample examples/user/createRunner.ts
     */
    createRunner({ runnerId, labels, description, }: {
        runnerId: string;
        labels: string[];
        description: string;
    }): Promise<MultiRunnerResponse.AsObject["runnersList"][0]>;
    /**
     * Returns an App object for the specified app ID.
     *
     * @param appId The app ID for the app to interact with.
     * @returns An App object for the specified app ID.
     *
     * @includeExample examples/user/app.ts
     */
    app({ appId, }: {
        appId: string;
    }): Promise<SingleAppResponse.AsObject["app"]>;
    /**
     * Returns a Runner object if exists.
     *
     * @param runnerId The runner ID to interact with.
     * @returns A Runner object for the existing runner ID.
     *
     * @includeExample examples/user/runner.ts
     */
    runner({ runnerId, }: {
        runnerId: string;
    }): Promise<SingleRunnerResponse.AsObject["runner"]>;
    /**
     * Deletes an app for the user.
     *
     * @param appId The app ID for the app to delete.
     *
     * @example examples/user/deleteApp.ts
     */
    deleteApp({ appId }: {
        appId: string;
    }): Promise<void>;
    /**
     * Deletes a runner for the user.
     *
     * @param runnerId The runner ID to delete.
     *
     * @includeExample examples/user/deleteRunner.ts
     */
    deleteRunner({ runnerId }: {
        runnerId: string;
    }): Promise<void>;
}
type USERID = string;
type APPID = string;
type RESOURCE_TYPE = string;
type RESOURCEID = string;
type RESOURCE_VERSION_TYPE = string;
type RESOURCE_VERSION_ID = string;
type ClarifaiUrl = `${string}://${string}/${USERID}/${APPID}/${RESOURCE_TYPE}/${RESOURCEID}/${RESOURCE_VERSION_TYPE}/${RESOURCE_VERSION_ID}` | `${string}://${string}/${USERID}/${APPID}/${RESOURCE_TYPE}/${RESOURCEID}`;
type ClarifaiAppUrl = `${string}://${string}/${USERID}/${APPID}`;
interface UploadEvents {
    start: ProgressEvent;
    progress: ProgressEvent;
    error: ErrorEvent;
    end: ProgressEvent;
}
interface ProgressEvent {
    current: number;
    total: number;
}
interface ErrorEvent {
    error: Error;
}
type BulkUploadEventEmitter<T> = EventEmitter & {
    emit<K extends keyof T>(event: K, payload: T[K]): boolean;
    on<K extends keyof T>(event: K, listener: (payload: T[K]) => void): void;
};
export type InputBulkUpload = BulkUploadEventEmitter<UploadEvents>;
/**
 * Inputs is a class that provides access to Clarifai API endpoints related to Input information.
 * @noInheritDoc
 */
export class Input extends Lister {
    /**
     * Initializes an input object.
     *
     * @param params - The parameters for the Input object.
     * @param params.userId - A user ID for authentication.
     * @param params.appId - An app ID for the application to interact with.
     * @param params.baseUrl - Base API url. Default "https://api.clarifai.com"
     * @param params.pat - A personal access token for authentication. Can be set as env var CLARIFAI_PAT
     * @param params.token - A session token for authentication. Accepts either a session token or a pat. Can be set as env var CLARIFAI_SESSION_TOKEN
     *
     * @includeExample examples/input/index.ts
     */
    constructor({ authConfig }: {
        authConfig?: AuthConfig;
    });
    /**
     * Creates an input proto from bytes.
     *
     * @param inputId - The input ID for the input to create.
     * @param imageBytes - The bytes for the image as `Uint8Array` or `null`.
     * @param videoBytes - The bytes for the video as `Uint8Array` or `null`.
     * @param audioBytes - The bytes for the audio as `Uint8Array` or `null`.
     * @param textBytes - The bytes for the text as `Uint8Array` or `null`.
     * @param datasetId - The dataset ID for the dataset to add the input to, can be `null`.
     * @returns An `Input` object for the specified input ID.
     *
     * @includeExample examples/input/getInputFromBytes.ts
     */
    static getInputFromBytes({ inputId, imageBytes, videoBytes, audioBytes, textBytes, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        imageBytes?: Uint8Array | null;
        videoBytes?: Uint8Array | null;
        audioBytes?: Uint8Array | null;
        textBytes?: Uint8Array | null;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): _Input1;
    /**
     * Create input proto from files.
     *
     * @param inputId - The input ID for the input to create.
     * @param imageFile - The file path for the image.
     * @param videoFile - The file path for the video.
     * @param audioFile - The file path for the audio.
     * @param textFile - The file path for the text.
     * @param datasetId - The dataset ID for the dataset to add the input to.
     * @returns - An Input object for the specified input ID.
     *
     * @includeExample examples/input/getInputFromFile.ts
     */
    static getInputFromFile({ inputId, imageFile, videoFile, audioFile, textFile, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        imageFile?: string | null;
        videoFile?: string | null;
        audioFile?: string | null;
        textFile?: string | null;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): _Input1;
    /**
     * Upload input from URL.
     *
     * @param inputId - The input ID for the input to create.
     * @param imageUrl - The URL for the image.
     * @param videoUrl - The URL for the video.
     * @param audioUrl - The URL for the audio.
     * @param textUrl - The URL for the text.
     * @param datasetId - The dataset ID for the dataset to add the input to.
     * @returns - Job ID for the upload request.
     *
     * @includeExample examples/input/getInputFromUrl.ts
     */
    static getInputFromUrl({ inputId, imageUrl, videoUrl, audioUrl, textUrl, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        imageUrl?: string | null;
        videoUrl?: string | null;
        audioUrl?: string | null;
        textUrl?: string | null;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): _Input1;
    /**
     * Upload image inputs from folder.
     *
     * @param folderPath - The path to the folder containing the images.
     * @param datasetId - The dataset ID for the dataset to add the input to.
     * @param labels - A boolean indicating whether to use the folder name as a label.
     *
     * @includeExample examples/input/getImageInputsFromFolder.ts
     */
    static getImageInputsFromFolder({ folderPath, datasetId, labels, }: {
        folderPath: string;
        datasetId?: string | null;
        labels?: boolean;
    }): _Input1[];
    /**
     * Create input proto for text data type from raw text.
     *
     * @param inputId - The input ID for the input to create.
     * @param rawText - The raw text input.
     * @param datasetId - The dataset ID for the dataset to add the input to.
     * @returns - An Input object for the specified input ID.
     *
     * @includeExample examples/input/getTextInput.ts
     */
    static getTextInput({ inputId, rawText, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        rawText: string;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): _Input1;
    /**
     * Create input proto for text and image from bytes or url
     *
     * @param inputId - The input ID for the input to create.
     * @param rawText - The raw text input.
     * @param datasetId - The dataset ID for the dataset to add the input to.
     * @param textBytes - The bytes for the text as `Uint8Array` or `Buffer`.
     * @param imageUrl - The URL for the image.
     * @param imageBytes - The bytes for the image as `Uint8Array` or `Buffer`.
     * @returns - An Input object for the specified input ID.
     */
    static getMultimodalInput({ inputId, rawText, textBytes, imageUrl, imageBytes, datasetId, labels, }: {
        inputId: string;
        rawText?: string | null;
        textBytes?: Uint8Array | null;
        imageUrl?: string | null;
        imageBytes?: Uint8Array | null;
        datasetId?: string | null;
        labels?: string[] | null;
    }): _Input1;
    /**
     * Create Input proto from CSV File. Supported columns are:
     * 'inputid', 'input', 'concepts', 'metadata', 'geopoints'
     *
     * @param csvPath - The path to the CSV file.
     * @param inputType - The type of input to create. Can be "text", "image", "video", or "audio".
     * @param csvType - The type of CSV file. Can be "raw", "url", or "file".
     * @param datasetId - The dataset ID for the dataset to add the input to.
     * @param labels - A boolean indicating whether to generate labels from concepts list.
     *
     * @returns - An array of Input objects for the specified input ID.
     */
    static getInputsFromCsv({ csvPath, inputType, csvType, datasetId, labels, }: {
        csvPath: string;
        inputType: "image" | "text" | "video" | "audio";
        csvType: "raw" | "url" | "file";
        datasetId?: string | null;
        labels: boolean;
    }): Promise<_Input1[]>;
    static getTextInputsFromFolder({ folderPath, datasetId, labels, }: {
        folderPath: string;
        datasetId: string | null;
        labels: boolean;
    }): _Input1[];
    static getBboxProto({ inputId, label, bbox, }: {
        inputId: string;
        label: string;
        bbox: number[];
    }): Annotation;
    static getMaskProto({ inputId, label, polygons, }: {
        inputId: string;
        label: string;
        polygons: Polygon[];
    }): Annotation;
    uploadInputs({ inputs, showLog, }: {
        inputs: _Input1[];
        showLog?: boolean;
    }): Promise<string>;
    uploadFromUrl({ inputId, imageUrl, videoUrl, audioUrl, textUrl, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        imageUrl?: string | null;
        videoUrl?: string | null;
        audioUrl?: string | null;
        textUrl?: string | null;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): Promise<string>;
    uploadFromFile({ inputId, imageFile, videoFile, audioFile, textFile, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        imageFile?: string | null;
        videoFile?: string | null;
        audioFile?: string | null;
        textFile?: string | null;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): Promise<string>;
    uploadFromBytes({ inputId, imageBytes, videoBytes, audioBytes, textBytes, datasetId, geoInfo, labels, metadata, }: {
        inputId: string;
        imageBytes?: Uint8Array | null;
        videoBytes?: Uint8Array | null;
        audioBytes?: Uint8Array | null;
        textBytes?: Uint8Array | null;
        datasetId?: string | null;
        geoInfo?: GeoPoint.AsObject | null;
        labels?: string[] | null;
        metadata?: Record<string, JavaScriptValue> | null;
    }): Promise<string>;
    uploadText({ inputId, rawText, datasetId, }: {
        inputId: string;
        rawText: string;
        datasetId?: string | null;
    }): Promise<string>;
    patchInputs({ inputs, action, }: {
        inputs: _Input1[];
        action?: string;
    }): Promise<string>;
    uploadAnnotations({ batchAnnot, showLog, }: {
        batchAnnot: Annotation[];
        showLog?: boolean;
    }): Promise<Annotation[]>;
    bulkUpload({ inputs, batchSize: providedBatchSize, uploadProgressEmitter, }: {
        inputs: _Input1[];
        batchSize?: number;
        uploadProgressEmitter?: InputBulkUpload;
    }): Promise<void>;
}
interface BaseModelConfig {
    modelVersion?: {
        id: string;
    };
}
interface ModelConfigWithUrl extends BaseModelConfig {
    url: ClarifaiUrl;
    modelId?: undefined;
    authConfig?: Omit<AuthConfig, "userId" | "appId">;
    modelUserAppId?: undefined;
}
interface ModelConfigWithModelId extends BaseModelConfig {
    url?: undefined;
    modelId: string;
    authConfig?: AuthConfig;
    modelUserAppId?: {
        userId: string;
        appId: string;
    };
}
type ModelConfig = ModelConfigWithUrl | ModelConfigWithModelId;
/**
 * Model is a class that provides access to Clarifai API endpoints related to Model information.
 * @noInheritDoc
 */
export class Model extends Lister {
    modelInfo: _Model1;
    /**
     * Initializes a Model object.
     *
     * @param url - The URL to initialize the model object.
     * @param modelId - The Model ID to interact with.
     * @param modelVersion - The Model Version to interact with.
     * @param authConfig - Authentication configuration options.
     * @param authConfig.baseURL - Base API URL. Default is "https://api.clarifai.com".
     * @param authConfig.pat - A personal access token for authentication. Can be set as env var CLARIFAI_PAT.
     * @param authConfig.token - A session token for authentication. Accepts either a session token or a pat. Can be set as env var CLARIFAI_SESSION_TOKEN.
     *
     * @includeExample examples/model/index.ts
     */
    constructor(config: ModelConfig);
    /**
     * Loads the current model info.
     * Usually called internally by other methods, to ensure the model info is loaded with latest data.
     */
    loadInfo(): Promise<void>;
    /**
     * Lists all the training templates for the model type.
     * @returns - A promise that resolves to a list of training templates for the model type.
     *
     * @includeExample examples/model/listTrainingTemplates.ts
     */
    listTrainingTemplates(): Promise<string[]>;
    /**
     * Returns the model params for the model type as object & also writes to a yaml file
     * @param template - The training template to use for the model type.
     * @param saveTo - The file path to save the yaml file.
     * @returns - A promise that resolves to the model params for the model type.
     *
     * @includeExample examples/model/getParams.ts
     */
    getParams(template?: string | null, saveTo?: string): Promise<Record<string, any>>;
    /**
     * Updates the model params for the model.
     * @param modelParams - The model params to update.
     *
     * @includeExample examples/model/updateParams.ts
     */
    updateParams(modelParams: Record<string, unknown>): void;
    /**
     * Returns the param info for the model.
     *
     * @includeExample examples/model/getParamInfo.ts
     */
    getParamInfo(param: string): Promise<Record<string, any>>;
    /**
     * Deletes a model version for the Model.
     *
     * @param versionId - The version ID to delete.
     *
     * @includeExample examples/model/deleteVersion.ts
     */
    deleteVersion(versionId: string): Promise<void>;
    /**
     * Creates a model version for the Model.
     *
     * @includeExample examples/model/createVersion.ts
     */
    createVersion(modelVersion: ModelVersion): Promise<_Model1.AsObject | undefined>;
    /**
     * Lists all the versions for the model.
     *
     * @includeExample examples/model/listVersions.ts
     *
     * @remarks
     * Defaults to 16 per page if pageNo is not specified
     */
    listVersions({ pageNo, perPage, }?: {
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<MultiModelVersionResponse.AsObject["modelVersionsList"], void, void>;
    /**
     * Predicts the model based on the given inputs.
     * Use the `Input` module to create the input objects.
     *
     * @param inputs - The inputs to predict, must be less than 128.
     * @param inferenceParams - The inference params to override.
     * @param outputConfig - The output config to override.
     *  min_value (number) - The minimum value of the prediction confidence to filter.
     *  max_concepts (number) - The maximum number of concepts to return.
     *  select_concepts (Concept[]) - The concepts to select.
     *  sample_ms (number) - The number of milliseconds to sample.
     * @returns - A promise that resolves to the model prediction.
     *
     * @includeExample examples/model/predict.ts
     */
    predict({ inputs, inferenceParams, outputConfig, }: {
        inputs: _Input1[];
        inferenceParams?: Record<string, JavaScriptValue>;
        outputConfig?: _OutputConfig1;
    }): Promise<MultiOutputResponse.AsObject["outputsList"]>;
    /**
     * Predicts the model based on the given inputs.
     * Inputs can be provided as a URL.
     * @param url - The URL of the input.
     * @param inputType - The type of the input. Can be "image", "text", "video", or "audio".
     * @param inferenceParams - The inference params to override.
     * @param outputConfig - The output config to override.
     * @returns - A promise that resolves to the model prediction.
     */
    predictByUrl({ url, inputType, inferenceParams, outputConfig, }: {
        url: string;
        inputType: "image" | "text" | "video" | "audio";
        inferenceParams?: Record<string, JavaScriptValue>;
        outputConfig?: _OutputConfig1;
    }): Promise<MultiOutputResponse.AsObject["outputsList"]>;
    /**
     * Predicts the model based on the given inputs.
     * Inputs can be provided as a filepath which can be read.
     * @param filepath - The filepath of the input.
     * @param inputType - The type of the input. Can be "image", "text", "video", or "audio".
     * @param inferenceParams - The inference params to override.
     * @param outputConfig - The output config to override.
     * @returns - A promise that resolves to the model prediction.
     */
    predictByFilepath({ filepath, inputType, inferenceParams, outputConfig, }: {
        filepath: string;
        inputType: "image" | "text" | "video" | "audio";
        inferenceParams?: Record<string, JavaScriptValue>;
        outputConfig?: _OutputConfig1;
    }): Promise<MultiOutputResponse.AsObject["outputsList"]>;
    /**
     * Predicts the model based on the given inputs.
     * Inputs can be provided as a Buffer.
     * @param inputBytes - Input as a buffer.
     * @param inputType - The type of the input. Can be "image", "text", "video", or "audio".
     * @param inferenceParams - The inference params to override.
     * @param outputConfig - The output config to override.
     * @returns - A promise that resolves to the model prediction.
     */
    predictByBytes({ inputBytes, inputType, inferenceParams, outputConfig, }: {
        inputBytes: Buffer;
        inputType: "image" | "text" | "video" | "audio";
        inferenceParams?: Record<string, JavaScriptValue>;
        outputConfig?: _OutputConfig1;
    }): Promise<MultiOutputResponse.AsObject["outputsList"]>;
}
export type AuthAppConfig = Omit<AuthConfig, "appId" | "userId"> & {
    appId?: undefined;
    userId?: undefined;
};
export type AppConfig = {
    url: ClarifaiAppUrl;
    authConfig: AuthAppConfig;
} | {
    url?: undefined;
    authConfig: AuthConfig;
};
export type ListDatasetsParam = PaginationRequestParams<ListDatasetsRequest.AsObject>;
export type ListModelsParam = PaginationRequestParams<ListModelsRequest.AsObject>;
export type ListWorkflowsParam = PaginationRequestParams<ListWorkflowsRequest.AsObject>;
export type ListModulesParam = PaginationRequestParams<ListModulesRequest.AsObject>;
export type ListInstalledModuleVersionsParam = PaginationRequestParams<ListInstalledModuleVersionsRequest.AsObject>;
export type CreateDatasetParam = Omit<Partial<_Dataset1.AsObject>, "id">;
export type CreateModelParam = Omit<Partial<_Model1.AsObject>, "id">;
/**
 * App is a class that provides access to Clarifai API endpoints related to App information.
 * @noInheritDoc
 */
export class App extends Lister {
    info: _App1.AsObject;
    /**
     * Initializes an App object.
     * @param config - The configuration object for the App.
     * @param config.url - The URL of the app.
     * @param config.authConfig.userId The user ID for the user to interact with.
     * @param config.authConfig.appId The application ID associated with the user. Not required if the URL is provided.
     * @param config.authConfig.pat A personal access token for authentication. Can also be set as an environment variable CLARIFAI_PAT.
     * @param config.authConfig.token A session token for authentication. Accepts either a session token or a personal access token (pat). Can also be set as an environment variable CLARIFAI_SESSION_TOKEN.
     * @param config.authConfig.base Optional. The base API URL. Defaults to "https://api.clarifai.com".
     * @param config.authConfig.ui Optional. Additional UI configurations.
     *
     * @includeExample examples/app/index.ts
     */
    constructor({ url, authConfig }: AppConfig);
    /**
     * Lists all the datasets for the app.
     *
     * @param pageNo - The page number to list.
     * @param perPage - The number of items per page.
     *
     * @yields Dataset - Dataset objects for the datasets in the app.
     *
     * @includeExample examples/app/listDatasets.ts
     *
     * @remarks
     * Defaults to 16 per page
     */
    listDataSets({ params, pageNo, perPage, }?: {
        params?: ListDatasetsParam;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<MultiDatasetResponse.AsObject["datasetsList"], void, unknown>;
    /**
     * Lists all the available models for the user.
     *
     * @param params - A object of filters to apply to the list of models.
     * @param onlyInApp - If True, only return models that are in the app.
     * @param pageNo - The page number to list.
     * @param perPage - The number of items per page.
     *
     * @includeExample examples/app/listModels.ts
     *
     * @remarks
     * Defaults to 16 per page
     */
    listModels({ params, onlyInApp, pageNo, perPage, }?: {
        params?: ListModelsParam;
        onlyInApp?: boolean;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<_Model1.AsObject[], void, unknown>;
    /**
     * Lists all the available workflows for the user.
     *
     * @param params - A object of filters to apply to the list of workflows.
     * @param onlyInApp - If True, only return workflows that are in the app.
     * @param pageNo - The page number to list.
     * @param perPage - The number of items per page.
     *
     * @yields Workflow - Workflow objects for the workflows in the app.
     *
     * @includeExample examples/app/listWorkflows.ts
     *
     * @remarks
     * Defaults to 16 per page
     */
    listWorkflows({ params, onlyInApp, pageNo, perPage, }?: {
        params?: ListWorkflowsParam;
        onlyInApp?: boolean;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<_Workflow1.AsObject[], void, unknown>;
    /**
     * Lists all the available modules for the user.
     *
     * @param params - An object of filters to apply to the list of modules.
     * @param onlyInApp - If true, only return modules that are in the app.
     * @param pageNo - The page number to list.
     * @param perPage - The number of items per page.
     *
     * @yields Module - Module objects for the modules in the app.
     *
     * @includeExample examples/app/listModules.ts
     *
     * @remarks
     * Defaults to 16 per page
     */
    listModules({ params, onlyInApp, pageNo, perPage, }?: {
        params?: ListModulesParam;
        onlyInApp?: boolean;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<Module.AsObject[], void, unknown>;
    /**
     * Lists all installed module versions in the app.
     *
     * @param params - A dictionary of filters to apply to the list of installed module versions.
     * @param pageNo - The page number to list.
     * @param perPage - The number of items per page.
     *
     * @yields Module - Module objects for the installed module versions in the app.
     *
     * @includeExample examples/app/listInstalledModuleVersions.ts
     *
     * @remarks
     * Defaults to 16 per page
     */
    listInstalledModuleVersions({ params, pageNo, perPage, }?: {
        params?: ListInstalledModuleVersionsParam;
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<InstalledModuleVersion.AsObject[], void, unknown>;
    /**
     * Lists all the concepts for the app.
     * @param page_no - The page number to list.
     * @param per_page - The number of items per page.
     * @yields Concepts in the app.
     *
     * @includeExample examples/app/listConcepts.ts
     */
    listConcepts({ pageNo, perPage, }?: {
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<Concept.AsObject[], void, unknown>;
    listTrainableModelTypes(): string[];
    /**
     * Creates a dataset for the app.
     *
     * @param datasetId - The dataset ID for the dataset to create.
     * @param params - Additional parameters to be passed to the Dataset.
     *
     * @returns A Dataset object for the specified dataset ID.
     *
     * @includeExample examples/app/createDataset.ts
     */
    createDataset({ datasetId, params, }: {
        datasetId: string;
        params?: CreateDatasetParam;
    }): Promise<_Dataset1.AsObject>;
    /**
     * Creates a model for the app.
     *
     * @param modelId - The model ID for the model to create.
     * @param params - Additional parameters to be passed to the Model.
     *
     * @returns A Model object for the specified model ID.
     *
     * @includeExample examples/app/createModel.ts
     */
    createModel({ modelId, params, }: {
        modelId: string;
        params?: CreateModelParam;
    }): Promise<_Model1.AsObject>;
    /**
     * Creates a module for the app.
     *
     * @param moduleId - The module ID for the module to create.
     * @param description - The description of the module to create.
     * @returns A Module object for the specified module ID.
     *
     * @includeExample examples/app/createModule.ts
     */
    createModule({ moduleId, description, }: {
        moduleId: string;
        description: string;
    }): Promise<Module.AsObject>;
    /**
     * Creates a workflow for the app.
     *
     * @param configFilePath - The path to the yaml workflow config file.
     * @param generateNewId - If true, generate a new workflow ID.
     * @param display - If true, display the workflow nodes tree.
     * @returns A Workflow object for the specified workflow config.
     *
     * @includeExample examples/app/createWorkflow.ts
     */
    createWorkflow({ configFilePath, generateNewId, display, }: {
        configFilePath: string;
        generateNewId?: boolean;
        display?: boolean;
    }): Promise<_Workflow1.AsObject>;
    /**
     * Returns a Model object for the existing model ID.
     *
     * @param modelId - The model ID for the existing model.
     * @param modelVersionId - Specific version id of the model.
     * @param modelUserAppId - The user app ID for the model.
     * @returns A model object for the specified model ID.
     *
     * @includeExample examples/app/model.ts
     */
    model({ modelId, modelVersionId, modelUserAppId, }: {
        modelId: string;
        modelVersionId?: string;
        modelUserAppId?: {
            userId: string;
            appId: string;
        };
    }): Promise<SingleModelResponse.AsObject["model"]>;
    /**
     * Returns a Workflow object for the existing workflow ID.
     *
     * @param workflowId - The workflow ID for a existing workflow.
     * @returns A workflow object for the specified workflow ID.
     *
     * @includeExample examples/app/workflow.ts
     */
    workflow({ workflowId, }: {
        workflowId: string;
    }): Promise<SingleWorkflowResponse.AsObject["workflow"]>;
    /**
     * Returns a Dataset object for the existing dataset ID.
     *
     * @param dataset_id - The dataset ID for the dataset to interact with.
     * @returns A Dataset object for the existing dataset ID.
     *
     * @includeExample examples/app/dataset.ts
     */
    dataset({ datasetId, }: {
        datasetId: string;
    }): Promise<SingleDatasetResponse.AsObject["dataset"]>;
    /**
     * Deletes a dataset for the user.
     *
     * @param datasetId - The dataset ID for the app to delete.
     *
     * @includeExample examples/app/deleteDataset.ts
     */
    deleteDataset({ datasetId }: {
        datasetId: string;
    }): Promise<void>;
    /**
     * Deletes a model for the user.
     *
     * @param modelId - The model ID for the model to delete.
     *
     * @includeExample examples/app/deleteModel.ts
     */
    deleteModel({ modelId }: {
        modelId: string;
    }): Promise<void>;
    /**
     * Deletes a workflow for the user.
     *
     * @param workflowId - The workflow ID for the workflow to delete.
     *
     * @includeExample examples/app/deleteWorkflow.ts
     */
    deleteWorkflow({ workflowId }: {
        workflowId: string;
    }): Promise<void>;
    /**
     * Deletes a module for the user.
     *
     * @param moduleId - The module ID for the module to delete.
     *
     * @includeExample examples/app/deleteModule.ts
     */
    deleteModule({ moduleId }: {
        moduleId: string;
    }): Promise<void>;
}
/**
 * Initialize the schema for rank and filter.
 * This schema validates:
 * - Rank and filter must be a list
 * - Each item in the list must be a dict
 * - The dict can contain these optional keys:
 *   - 'image_url': Valid URL string
 *   - 'text_raw': Non-empty string
 *   - 'metadata': Dict
 *   - 'image_bytes': Bytes
 *   - 'geo_point': Dict with 'longitude', 'latitude' and 'geo_limit' as float, float and int respectively
 *   - 'concepts': List where each item is a concept dict
 * - Concept dict requires at least one of:
 *   - 'name': Non-empty string with dashes/underscores
 *   - 'id': Non-empty string
 *   - 'language': Non-empty string
 *   - 'value': 0 or 1 integer
 * - 'input_types': List of 'image', 'video', 'text' or 'audio'
 * - 'input_dataset_ids': List of strings
 * - 'input_status_code': Integer
 *
 * @returns The schema for rank and filter, defining the structure and validation rules for each item.
 */
declare function getSchema(): z.ZodSchema<Array<{
    imageUrl?: string;
    textRaw?: string;
    metadata?: Record<string, unknown>;
    imageBytes?: unknown;
    geoPoint?: {
        longitude: number;
        latitude: number;
        geoLimit: number;
    };
    concepts?: Array<{
        value?: number;
        id?: string;
        language?: string;
        name?: string;
    }>;
    inputTypes?: Array<"image" | "video" | "text" | "audio">;
    inputDatasetIds?: string[];
    inputStatusCode?: number;
}>>;
type FilterType = z.infer<ReturnType<typeof getSchema>>;
type SupportedAlgorithm = "nearest_neighbor" | "brute_force";
type SupportedMetric = "cosine" | "euclidean";
/**
 * @noInheritDoc
 */
export class Search extends Lister {
    constructor({ topK, metric, authConfig, algorithm, }: {
        topK?: number;
        metric?: SupportedMetric;
        authConfig?: AuthConfig;
        algorithm?: SupportedAlgorithm;
    });
    query({ ranks, filters, page, perPage, }: {
        ranks?: FilterType;
        filters?: FilterType;
        page?: number;
        perPage?: number;
    }): AsyncGenerator<MultiSearchResponse.AsObject, void, void>;
}
type OutputConfig = {
    minValue: number;
};
type WorkflowConfig = {
    url: ClarifaiUrl;
    workflowId?: undefined;
    workflowVersion?: undefined;
    outputConfig?: OutputConfig;
    authConfig?: Omit<AuthConfig, "userId" | "appId"> & {
        appId?: undefined;
        userId?: undefined;
    };
} | {
    url?: undefined;
    workflowId: string;
    workflowVersion?: {
        id: string;
    };
    outputConfig?: OutputConfig;
    authConfig?: AuthConfig;
};
/**
 * @noInheritDoc
 */
export class Workflow extends Lister {
    id: string;
    appId: string;
    constructor({ url, workflowId, workflowVersion, outputConfig, authConfig, }: WorkflowConfig);
    predict({ inputs, workflowStateId, }: {
        inputs: _Input1[];
        workflowStateId?: WorkflowState.AsObject["id"];
    }): Promise<PostWorkflowResultsResponse.AsObject>;
    predictByBytes(inputBytes: Buffer, inputType: "image" | "text" | "video" | "audio"): Promise<PostWorkflowResultsResponse.AsObject>;
    predictByUrl(url: string, inputType: "image" | "text" | "video" | "audio"): Promise<PostWorkflowResultsResponse.AsObject>;
    listVersions({ pageNo, perPage, }: {
        pageNo?: number;
        perPage?: number;
    }): AsyncGenerator<MultiWorkflowVersionResponse.AsObject, void, void>;
    /**
     * Exports the workflow to a yaml file.
     *
     * @param outPath - The path to save the yaml file to.
     *
     * @example
     * ```typescript
     * import { Workflow } from "./workflow";
     *
     * const workflow = new Workflow("https://clarifai.com/clarifai/main/workflows/Demographics");
     * await workflow.export("out_path.yml");
     * ```
     */
    exportWorkflow(outPath: string): Promise<void>;
}
type DatasetConfig = {
    authConfig?: AuthConfig;
    datasetId: string;
    datasetVersionId?: string;
    url?: undefined;
} | {
    authConfig?: AuthConfig;
    datasetId?: undefined;
    datasetVersionId?: undefined;
    url: ClarifaiUrl;
};
export class Dataset extends Lister {
    constructor({ authConfig, datasetId, url, datasetVersionId }: DatasetConfig);
    createVersion({ id, description, metadata, }: {
        id: string;
        description: string;
        metadata?: Record<string, JavaScriptValue>;
    }): Promise<DatasetVersion.AsObject>;
    deleteVersion(versionId: string): Promise<void>;
    listVersions(pageNo?: number, perPage?: number): AsyncGenerator<DatasetVersion.AsObject[], void, unknown>;
    uploadFromFolder({ folderPath, inputType, labels, batchSize, uploadProgressEmitter, }: {
        folderPath: string;
        inputType: "image" | "text";
        labels?: boolean;
        batchSize?: number;
        uploadProgressEmitter?: InputBulkUpload;
    }): Promise<void>;
    uploadFromCSV({ csvPath, inputType, csvType, labels, batchSize, uploadProgressEmitter, }: {
        csvPath: string;
        inputType?: "image" | "text" | "video" | "audio";
        csvType: "raw" | "url" | "file";
        labels?: boolean;
        batchSize?: number;
        uploadProgressEmitter?: InputBulkUpload;
    }): Promise<void>;
}
interface Message {
    role: string;
    content: string;
}
type UrlAuthConfig = Omit<AuthConfig, "userId" | "appId"> & {
    appId?: undefined;
    userId?: undefined;
};
type RAGConfigWithURL = {
    workflowUrl: ClarifaiUrl;
    workflow?: undefined;
    authConfig?: UrlAuthConfig;
};
type RAGConfigWithWorkflow = {
    workflowUrl?: undefined;
    workflow: Workflow;
    authConfig?: AuthConfig;
};
type RAGConfig = RAGConfigWithURL | RAGConfigWithWorkflow;
export class RAG {
    promptWorkflow: Workflow;
    app: App;
    constructor({ workflowUrl, workflow, authConfig }: RAGConfig);
    static setup({ authConfig, appUrl, llmUrl, baseWorkflow, workflowYamlFilename, promptTemplate, workflowId, minScore, maxResults, }: {
        authConfig?: (Omit<AuthConfig, "appId"> & {
            appId?: undefined;
        }) | AuthAppConfig;
        appUrl?: ClarifaiAppUrl;
        llmUrl?: ClarifaiUrl;
        baseWorkflow?: string;
        workflowYamlFilename?: string;
        promptTemplate?: string;
        workflowId?: string;
        minScore?: number;
        maxResults?: number;
    }): Promise<RAG>;
    upload({ filePath, folderPath, url, batchSize, chunkSize, chunkOverlap, datasetId, metadata, }: {
        filePath?: string;
        folderPath?: string;
        url?: string;
        batchSize?: number;
        chunkSize?: number;
        chunkOverlap?: number;
        datasetId?: string;
        metadata?: Record<string, JavaScriptValue>;
    }): Promise<void>;
    chat({ messages, clientManageState, }: {
        messages: Message[];
        clientManageState?: boolean;
    }): Promise<Message[]>;
}

//# sourceMappingURL=types.d.ts.map
