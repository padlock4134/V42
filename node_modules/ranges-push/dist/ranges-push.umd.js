/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 7.0.18
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */

"use strict";var rangesPush=(()=>{var J=Object.create;var T=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames,S=Object.getOwnPropertySymbols,W=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty,_=Object.prototype.propertyIsEnumerable;var R=(r,e,o)=>e in r?T(r,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[e]=o,y=(r,e)=>{for(var o in e||(e={}))v.call(e,o)&&R(r,o,e[o]);if(S)for(var o of S(e))_.call(e,o)&&R(r,o,e[o]);return r};var H=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),M=(r,e)=>{for(var o in e)T(r,o,{get:e[o],enumerable:!0})},N=(r,e,o,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let c of L(e))!v.call(r,c)&&c!==o&&T(r,c,{get:()=>e[c],enumerable:!(i=B(e,c))||i.enumerable});return r};var P=(r,e,o)=>(o=r!=null?J(W(r)):{},N(e||!r||!r.__esModule?T(o,"default",{value:r,enumerable:!0}):o,r)),U=r=>N(T({},"__esModule",{value:!0}),r);var w=(r,e,o)=>R(r,typeof e!="symbol"?e+"":e,o);var x=H((ee,j)=>{"use strict";j.exports=q;function b(r){return r instanceof Buffer?Buffer.from(r):new r.constructor(r.buffer.slice(),r.byteOffset,r.length)}function q(r){if(r=r||{},r.circles)return G(r);let e=new Map;if(e.set(Date,l=>new Date(l)),e.set(Map,(l,a)=>new Map(i(Array.from(l),a))),e.set(Set,(l,a)=>new Set(i(Array.from(l),a))),r.constructorHandlers)for(let l of r.constructorHandlers)e.set(l[0],l[1]);let o=null;return r.proto?n:c;function i(l,a){let t=Object.keys(l),u=new Array(t.length);for(let s=0;s<t.length;s++){let g=t[s],f=l[g];typeof f!="object"||f===null?u[g]=f:f.constructor!==Object&&(o=e.get(f.constructor))?u[g]=o(f,a):ArrayBuffer.isView(f)?u[g]=b(f):u[g]=a(f)}return u}function c(l){if(typeof l!="object"||l===null)return l;if(Array.isArray(l))return i(l,c);if(l.constructor!==Object&&(o=e.get(l.constructor)))return o(l,c);let a={};for(let t in l){if(Object.hasOwnProperty.call(l,t)===!1)continue;let u=l[t];typeof u!="object"||u===null?a[t]=u:u.constructor!==Object&&(o=e.get(u.constructor))?a[t]=o(u,c):ArrayBuffer.isView(u)?a[t]=b(u):a[t]=c(u)}return a}function n(l){if(typeof l!="object"||l===null)return l;if(Array.isArray(l))return i(l,n);if(l.constructor!==Object&&(o=e.get(l.constructor)))return o(l,n);let a={};for(let t in l){let u=l[t];typeof u!="object"||u===null?a[t]=u:u.constructor!==Object&&(o=e.get(u.constructor))?a[t]=o(u,n):ArrayBuffer.isView(u)?a[t]=b(u):a[t]=n(u)}return a}}function G(r){let e=[],o=[],i=new Map;if(i.set(Date,t=>new Date(t)),i.set(Map,(t,u)=>new Map(n(Array.from(t),u))),i.set(Set,(t,u)=>new Set(n(Array.from(t),u))),r.constructorHandlers)for(let t of r.constructorHandlers)i.set(t[0],t[1]);let c=null;return r.proto?a:l;function n(t,u){let s=Object.keys(t),g=new Array(s.length);for(let f=0;f<s.length;f++){let p=s[f],m=t[p];if(typeof m!="object"||m===null)g[p]=m;else if(m.constructor!==Object&&(c=i.get(m.constructor)))g[p]=c(m,u);else if(ArrayBuffer.isView(m))g[p]=b(m);else{let D=e.indexOf(m);D!==-1?g[p]=o[D]:g[p]=u(m)}}return g}function l(t){if(typeof t!="object"||t===null)return t;if(Array.isArray(t))return n(t,l);if(t.constructor!==Object&&(c=i.get(t.constructor)))return c(t,l);let u={};e.push(t),o.push(u);for(let s in t){if(Object.hasOwnProperty.call(t,s)===!1)continue;let g=t[s];if(typeof g!="object"||g===null)u[s]=g;else if(g.constructor!==Object&&(c=i.get(g.constructor)))u[s]=c(g,l);else if(ArrayBuffer.isView(g))u[s]=b(g);else{let f=e.indexOf(g);f!==-1?u[s]=o[f]:u[s]=l(g)}}return e.pop(),o.pop(),u}function a(t){if(typeof t!="object"||t===null)return t;if(Array.isArray(t))return n(t,a);if(t.constructor!==Object&&(c=i.get(t.constructor)))return c(t,a);let u={};e.push(t),o.push(u);for(let s in t){let g=t[s];if(typeof g!="object"||g===null)u[s]=g;else if(g.constructor!==Object&&(c=i.get(g.constructor)))u[s]=c(g,a);else if(ArrayBuffer.isView(g))u[s]=b(g);else{let f=e.indexOf(g);f!==-1?u[s]=o[f]:u[s]=a(g)}}return e.pop(),o.pop(),u}}});var Y={};M(Y,{Ranges:()=>E,defaults:()=>F,version:()=>K});function A(r,e=1){let o="\xA0";function i(n){return Array.from(n).reverse().join("")}function c(n,l,a){let t=a?`
`:"\r",u=a?"\r":`
`;if(!n)return n;let s=0,g=0,f="";for(let p=0,m=n.length;p<m;p++)(n[p]===t||n[p]===u&&n[p-1]!==t)&&g++,`\r
`.includes(n[p])||n[p]===o?(s=0,n[p]===o?f+=n[p]:n[p]===t?g<=l&&(f+=n[p],n[p+1]===u&&(f+=n[p+1],p++)):n[p]===u&&(n==null?void 0:n[p-1])!==t&&g<=l&&(f+=n[p])):(s++,!n[p+1]&&!g&&(f+=" "));return f}if(typeof r=="string"&&r.length){let n=1;typeof+e=="number"&&Number.isInteger(+e)&&+e>=0&&(n=+e);let l="",a="";if(!r.trim())l=r;else if(!r[0].trim()){for(let t=0,u=r.length;t<u;t++)if(r[t].trim()){l=r.slice(0,t);break}}if(r.trim()&&(r.slice(-1).trim()===""||r.slice(-1)===o)){for(let t=r.length;t--;)if(r[t].trim()){a=r.slice(t+1);break}}return`${c(l,n,!1)}${r.trim()}${i(c(i(a),n,!0))}`}return r}var V=P(x(),1);var re=(0,V.default)();function $(r){return typeof r=="string"}function h(r){return Number.isSafeInteger(r)&&r>=0}function d(r){return r!=null}var Q={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function O(r,e){if(!Array.isArray(r)||!r.length)return r;let o=y(y({},Q),e),i,c;if(o.strictlyTwoElementsInRangeArrays&&!r.every((a,t)=>!Array.isArray(a)||a.length!==2?(i=t,c=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${i}th range (${JSON.stringify(r[i],null,4)}) has not two but ${c} elements!`);if(!r.every((a,t)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(i=t,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${i}th range (${JSON.stringify(r[i],null,4)}) does not consist of only natural numbers!`);let n=r.length**2,l=0;return Array.from(r).sort((a,t)=>(o.progressFn&&(l+=1,o.progressFn(Math.floor(l*100/n))),a[0]===t[0]?a[1]<t[1]?-1:a[1]>t[1]?1:0:a[0]<t[0]?-1:1))}var C="7.0.18";var I={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function k(r,e){var u;function o(s){return!!s&&typeof s=="object"&&!Array.isArray(s)}if(!Array.isArray(r)||!r.length)return null;let i;if(e)if(o(e)){if(i=y(y({},I),e),i.progressFn&&o(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&typeof i.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof i.progressFn}", equal to ${JSON.stringify(i.progressFn,null,4)}`);if(![1,2,"1","2"].includes(i.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);if(typeof i.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof i.joinRangesThatTouchEdges}", equal to ${JSON.stringify(i.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`ranges-merge: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(e,null,4)} (type ${typeof e})`);else i=y({},I);let c=r.filter(s=>Array.isArray(s)).map(s=>[...s]).filter(s=>s[2]!==void 0||s[0]!==s[1]),n,l,a;i.progressFn?n=O(c,{progressFn:s=>{a=Math.floor(s/5),a!==l&&(l=a,i.progressFn!=null&&i.progressFn(a))}}):n=O(c);let t=n.length-1;for(let s=t;s>0;s--)i.progressFn&&(a=Math.floor((1-s/t)*78)+21,a!==l&&a>l&&(l=a,i.progressFn(a))),(n[s][0]<=n[s-1][0]||!i.joinRangesThatTouchEdges&&n[s][0]<n[s-1][1]||i.joinRangesThatTouchEdges&&n[s][0]<=n[s-1][1])&&(n[s-1][0]=Math.min(n[s][0],n[s-1][0]),n[s-1][1]=Math.max(n[s][1],n[s-1][1]),n[s][2]!==void 0&&(n[s-1][0]>=n[s][0]||n[s-1][1]<=n[s][1])&&n[s-1][2]!==null&&(n[s][2]===null&&n[s-1][2]!==null?n[s-1][2]=null:n[s-1][2]!=null?+((u=i||{})==null?void 0:u.mergeType)==2&&n[s-1][0]===n[s][0]?n[s-1][2]=n[s][2]:n[s-1][2]+=n[s][2]:n[s-1][2]=n[s][2]),n.splice(s,1),s=n.length);return n.length?n:null}var K=C,F={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},E=class{constructor(e){w(this,"ranges");w(this,"opts");let o=y(y({},F),e);if(o.mergeType&&o.mergeType!==1&&o.mergeType!==2)if($(o.mergeType)&&o.mergeType.trim()==="1")o.mergeType=1;else if($(o.mergeType)&&o.mergeType.trim()==="2")o.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof o.mergeType}", equal to ${JSON.stringify(o.mergeType,null,4)}`);this.opts=o,this.ranges=[]}add(e,o,i){var l;if(e==null&&o==null)return;if(d(e)&&!d(o)){if(Array.isArray(e)){if(e.length){if(e.some(a=>Array.isArray(a))){e.forEach(a=>{Array.isArray(a)&&this.add(...a)});return}e.length&&h(+e[0])&&h(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(o,null,0)})`)}else if(!d(e)&&d(o))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(o,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let c=+e,n=+o;if(h(i)&&(i=String(i)),h(c)&&h(n)){if(d(i)&&!$(i)&&!h(i))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof i}, equal to:
${JSON.stringify(i,null,4)}`);if(d(this.ranges)&&Array.isArray(this.last())&&c===this.last()[1]){if(this.last()[1]=n,this.last()[2],this.last()[2]!==null&&d(i)){let a=this.last()[2]&&this.last()[2].length&&(!((l=this.opts)!=null&&l.mergeType)||this.opts.mergeType===1)?`${this.last()[2]}${i}`:i;this.opts.limitToBeAddedWhitespace&&(a=A(a,this.opts.limitLinebreaksCount)),$(a)&&!a.length||(this.last()[2]=a)}}else{this.ranges||(this.ranges=[]);let a=i!==void 0&&!($(i)&&!i.length)?[c,n,i&&this.opts.limitToBeAddedWhitespace?A(i,this.opts.limitLinebreaksCount):i]:[c,n];this.ranges.push(a)}}else throw h(c)&&c>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof n}" equal to: ${JSON.stringify(n,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof c}" equal to: ${JSON.stringify(c,null,4)}`)}push(e,o,i){this.add(e,o,i)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=k(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>d(e[2])?[e[0],e[1],A(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&h(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};return U(Y);})();
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 7.0.9
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.6.7
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.0.13
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
