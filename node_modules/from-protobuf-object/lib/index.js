"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromProtobufObject = void 0;
const google_protobuf_1 = require("google-protobuf");
function fromProtobufObject(MessageType, data) {
    const instance = new MessageType();
    validateMissingProps(instance, data);
    for (const [key, value] of Object.entries(filterExtraProps(instance, data))) {
        const prop = getActualKey(key);
        if (Array.isArray(value) && isProtobufMap(instance, prop)) {
            const mapMethod = getMethod(prop, "get" /* PREFIX.GET */);
            const map = callMethod(instance, mapMethod);
            const NestedType = retrieveNestedMapTypePatch(instance, prop);
            for (const [k, v] of value) {
                if (!isObject(v, prop)) {
                    map.set(k, v);
                    continue;
                }
                if (!NestedType) {
                    throw new Error('Unable to retrieve nested type');
                }
                map.set(k, fromProtobufObject(NestedType, v));
            }
            continue;
        }
        const result = getResult(instance, prop, value);
        validateType(instance, prop, value);
        const setter = getMethod(prop, "set" /* PREFIX.SET */);
        callMethod(instance, setter, result);
    }
    return instance;
}
exports.fromProtobufObject = fromProtobufObject;
function getResult(instance, prop, value) {
    if (value instanceof Uint8Array) {
        return value;
    }
    if (Array.isArray(value)) {
        if (value.length === 0 || !isArrayOfObjects(value, prop)) {
            return value;
        }
        const NestedType = retrieveNestedRepeatedTypePatch(instance, prop);
        if (!NestedType) {
            throw new Error('Unable to retrieve nested type');
        }
        return value.map((child) => fromProtobufObject(NestedType, child));
    }
    if (isObject(value, prop)) {
        const NestedType = retrieveNestedTypePatch(instance, prop);
        if (!NestedType) {
            throw new Error('Unable to retrieve nested type');
        }
        return fromProtobufObject(NestedType, value);
    }
    return value;
}
function callMethod(obj, key, value) {
    return obj[key](value);
}
function getActualKey(key) {
    return key === 'pb_default' ? 'default' : key;
}
function getProp(key, prefix) {
    const prop = getActualKey(key).slice(prefix.length);
    return prop.slice(0, 1).toLowerCase() + prop.slice(1);
}
function getMethod(prop, prefix) {
    return `${prefix}${prop[0].toUpperCase()}${prop.slice(1)}`;
}
function getInstancePropsFromKeys(keys, prefix) {
    return keys
        .filter((key) => key.startsWith(prefix))
        .map(key => getProp(key, prefix));
}
function getInstanceProps(instance) {
    const keys = Object.keys(Object.getPrototypeOf(instance));
    const setters = getInstancePropsFromKeys(keys, "set" /* PREFIX.SET */);
    const maps = getInstancePropsFromKeys(keys, "clear" /* PREFIX.CLEAR */).filter(prop => isProtobufMap(instance, prop));
    return [...setters, ...maps];
}
function isProtobufMap(instance, prop) {
    return callMethod(instance, getMethod(prop, "get" /* PREFIX.GET */)) instanceof google_protobuf_1.Map;
}
function isOptional(instance, prop) {
    const clearMethod = getMethod(prop, "clear" /* PREFIX.CLEAR */);
    return clearMethod in instance;
}
function validateMissingProps(instance, data) {
    const instanceProps = getInstanceProps(instance);
    const dataKeys = Object.keys(data).map(getActualKey);
    for (const prop of instanceProps) {
        if (!dataKeys.includes(prop) && !isOptional(instance, prop)) {
            throw new Error(`Missing property '${prop}'`);
        }
    }
}
function filterExtraProps(instance, data) {
    const instanceProps = getInstanceProps(instance);
    return Object.fromEntries(Object.entries(data).filter(([key, value]) => instanceProps.includes(getActualKey(key)) && value !== undefined));
}
function isObject(value, prop) {
    if (value === null) {
        throw new Error(`Null value for key '${prop}'`);
    }
    return typeof value === 'object';
}
function isArrayOfObjects(arr, prop) {
    if (arr.every((item) => isObject(item, prop))) {
        return true;
    }
    if (arr.every((item) => !isObject(item, prop))) {
        return false;
    }
    throw new Error(`Mixed array for '${prop}'`);
}
function validateType(instance, prop, value) {
    const getter = getMethod(prop, "get" /* PREFIX.GET */);
    const instanceValue = callMethod(instance, getter);
    const expectedType = instanceValue !== undefined ? typeof instanceValue : 'object';
    const actualType = value instanceof Uint8Array ? 'string' : typeof value;
    if (Array.isArray(instanceValue) && !Array.isArray(value)) {
        throw new Error(`Invalid type for '${prop}' (expected array, got '${actualType}')`);
    }
    if (!Array.isArray(instanceValue) && Array.isArray(value)) {
        throw new Error(`Invalid type for '${prop}' (expected '${expectedType}', got array)`);
    }
    if (expectedType !== actualType) {
        throw new Error(`Invalid type for '${prop}' (expected '${expectedType}', got '${actualType}')`);
    }
}
function retrieveNestedTypePatch(instance, prop) {
    const getWrapperField = google_protobuf_1.Message.getWrapperField;
    let nestedType = null;
    google_protobuf_1.Message.getWrapperField = function (msg, ctor, fieldNumber, required) {
        nestedType = ctor;
        return getWrapperField(msg, ctor, fieldNumber, required);
    };
    callMethod(instance, getMethod(prop, "get" /* PREFIX.GET */));
    google_protobuf_1.Message.getWrapperField = getWrapperField;
    return nestedType;
}
function retrieveNestedRepeatedTypePatch(instance, prop) {
    const getRepeatedWrapperField = google_protobuf_1.Message.getRepeatedWrapperField;
    let nestedType = null;
    google_protobuf_1.Message.getRepeatedWrapperField = function (msg, ctor, fieldNumber) {
        nestedType = ctor;
        return getRepeatedWrapperField(msg, ctor, fieldNumber);
    };
    callMethod(instance, getMethod(prop, "get" /* PREFIX.GET */));
    google_protobuf_1.Message.getRepeatedWrapperField = getRepeatedWrapperField;
    return nestedType;
}
function retrieveNestedMapTypePatch(instance, prop) {
    const getMapField = google_protobuf_1.Message.getMapField;
    let nestedType = null;
    google_protobuf_1.Message.getMapField = function (msg, fieldNumber, noLazyCreate, valueCtor) {
        nestedType = valueCtor ?? null;
        return getMapField(msg, fieldNumber, noLazyCreate, valueCtor);
    };
    callMethod(instance, getMethod(prop, "get" /* PREFIX.GET */));
    google_protobuf_1.Message.getMapField = getMapField;
    return nestedType;
}
